<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" href="/css/github.css?2018.08.01">

<title>Net Lover</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="description" content="DotNet技术和网络技术爱好者，专注于前端框架、微服务、架构、开源技术，提供优质系列文章服务同道者！">
<meta name="keywords" content=".Net,Net,微服务,架构,框架,开源,前端技术">
<meta property="og:type" content="website">
<meta property="og:title" content="Net Lover">
<meta property="og:url" content="https://netlover.cn/index.html">
<meta property="og:site_name" content="Net Lover">
<meta property="og:description" content="DotNet技术和网络技术爱好者，专注于前端框架、微服务、架构、开源技术，提供优质系列文章服务同道者！">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Net Lover">
<meta name="twitter:description" content="DotNet技术和网络技术爱好者，专注于前端框架、微服务、架构、开源技术，提供优质系列文章服务同道者！">

<link rel="alternative" href="/atom.xml" title="Net Lover" type="application/atom+xml">


<link rel="icon" href="/img/netlover.ico?2018.08.01">

<link rel="stylesheet" href="/css/style.css?2018.08.01">
<script src="/js/jquery1.8.2.min.js?2018.08.01"></script>
<script src="/js/jquery.qrcode.min.js?2018.08.01"></script>
<script src="/js/ug-theme-default.js?2018.08.01"></script>
<script src="/js/unitegallery.js?2018.08.01"></script>
<script src="/js/gitment.browser.js?2018.08.01"></script>
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="/img/netlover.jpg" class="js-avatar">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Net Lover</a></h1>
		</hgroup>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories">分类</a></li>
				        
							<li><a href="/archives">归档</a></li>
				        
							<li><a href="/tags">标签</a></li>
				        
							<li><a href="/about">关于</a></li>
				        
						</ul>
					</nav>
					<nav class="site-state motion-element">
						<div class="site-state-item site-state-posts">
							<a href="/archives">
							<span class="site-state-item-count">18</span>
							<span class="site-state-item-name">日志</span>
							</a>
						</div>
						<div class="site-state-item site-state-categories">
							<a href="/categories/index.html">
							<span class="site-state-item-count">8</span>
							<span class="site-state-item-name">分类</span>
							</a>
						</div>
						<div class="site-state-item site-state-tags">
							<a href="/tags/index.html">
							<span class="site-state-item-count">40</span>
							<span class="site-state-item-name">标签</span>
							</a>
						</div>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								
									<a class="github" target="_blank" href="https://github.com/Netlover" title="github">github</a>
								
					        
								
									<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
								
					        
								
									<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/netlover" title="zhihu">zhihu</a>
								
					        
								
									<a class="jianshu" target="_blank" href="https://www.jianshu.com/u/c86d7c57dd6d" title="jianshu">jianshu</a>
								
					        
						</div>
						<div class="gongzhonghao"><img src="/img/gongzhonghao.jpg"></div>
					</nav>
				</section>

				

				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">网络爱好者，.Net爱好者...</div>
				</section>
				
			</div>
		</div>
	</header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Net Lover</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="/img/netlover.jpg" class="js-avatar">
				<hgroup>
				  <h1 class="header-author">Net Lover</h1>
				</hgroup>
			</div>
			
			<p class="header-subtitle">.Net Lover &amp; Net Lover</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories">分类</a></li>
		        
					<li><a href="/archives">归档</a></li>
		        
					<li><a href="/tags">标签</a></li>
		        
					<li><a href="/about">关于</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Netlover" title="github">github</a>
			        
						<a class="rss" target="_blank" href="/atom.xml" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="https://zhuanlan.zhihu.com/netlover" title="zhihu">zhihu</a>
			        
						<a class="jianshu" target="_blank" href="https://www.jianshu.com/u/c86d7c57dd6d" title="jianshu">jianshu</a>
			        
				</div>
			</nav>
		</header>
	</div>
</nav>

      <div class="body-wrap">


  
    <article id="post-十种常见的软件架构模式" class="article article-type-post" itemscope itemprop="blogPost">
    
        <div class="article-meta">
            <a href="/2018/08/20/10pattern.html" class="article-date">
  	<time datetime="2018-08-20T15:35:44.000Z" itemprop="datePublished">2018-08-20</time>
</a>

        </div>
        
            <div class="article-inner">
                
                    <input type="hidden" class="isFancy" />
                    
                        
                            <header class="article-header">
                                
  
    <h1 class="article-title" itemprop="name">
      <a href="/2018/08/20/10pattern.html">十种常见的软件架构模式</a>
    </h1>
  


                            </header>
                            <div class="article-info article-info-post">
                                    
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/架构/">架构</a>
	</div>


                                    <div class="clearfix"></div>
                                </div>
                                    
                                        <div class="article-entry" itemprop="articleBody">
                                            
                                            
                                            
                                                        <blockquote>
<p>有没有想过要设计多大的企业规模系统？在主要的软件开发开始之前，我们必须选择一个合适的体系结构，它将为我们提供所需的功能和质量属性。因此，在将它们应用到我们的设计之前，我们应该了解不同的体系结构。</p>
</blockquote>
<p><img src="https://i.imgur.com/QZe8ilM.png" alt=""></p>
<h2 id="什么是架构模式？"><a href="#什么是架构模式？" class="headerlink" title="什么是架构模式？"></a>什么是架构模式？</h2><p><strong>根据维基百科中的定义：</strong></p>
<blockquote>
<p>架构模式是一个通用的、可重用的解决方案，用于在给定上下文中的软件体系结构中经常出现的问题。架构模式与软件设计模式类似，但具有更广泛的范围。</p>
</blockquote>
<p>在本文中，将简要地解释以下10种常见的体系架构模式，以及它们的用法、优缺点。</p>
<ol>
<li>分层模式</li>
<li>客户端-服务器模式</li>
<li>主从设备模式</li>
<li>管道-过滤器模式</li>
<li>代理模式</li>
<li>点对点模式</li>
<li>事件总线模式</li>
<li>模型-视图-控制器模式</li>
<li>黑板模式</li>
<li>解释器模式</li>
</ol>
<h2 id="一-分层模式"><a href="#一-分层模式" class="headerlink" title="一. 分层模式"></a>一. 分层模式</h2><p>这种模式也称为多层体系架构模式。它可以用来构造可以分解为子任务组的程序，每个子任务都处于一个特定的抽象级别。每个层都为下一个提供更高层次服务。</p>
<p>一般信息系统中最常见的是如下所列的4层。</p>
<ul>
<li>表示层(也称为UI层)</li>
<li>应用层(也称为服务层)</li>
<li>业务逻辑层(也称为领域层)</li>
<li>数据访问层(也称为持久化层)</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>一般的桌面应用程序</li>
<li>电子商务Web应用程序</li>
</ul>
<p><img src="https://i.imgur.com/UGdkG97.png" alt=""></p>
<h2 id="二-客户端-服务器模式"><a href="#二-客户端-服务器模式" class="headerlink" title="二. 客户端-服务器模式"></a>二. 客户端-服务器模式</h2><p>这种模式由两部分组成：一个服务器和多个客户端。服务器组件将为多个客户端组件提供服务。客户端从服务器请求服务，服务器为这些客户端提供相关服务。此外，服务器持续侦听客户机请求。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>电子邮件，文件共享和银行等在线应用程序</li>
</ul>
<p><img src="https://i.imgur.com/MFgffP7.png" alt=""></p>
<h2 id="三-主从设备模式"><a href="#三-主从设备模式" class="headerlink" title="三. 主从设备模式"></a>三. 主从设备模式</h2><p>这种模式由两方组成;主设备和从设备。主设备组件在相同的从设备组件中分配工作，并计算最终结果，这些结果是由从设备返回的结果。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>在数据库复制中，主数据库被认为是权威的来源，并且要与之同步</li>
<li>在计算机系统中与总线连接的外围设备(主和从驱动器)</li>
</ul>
<p><img src="https://i.imgur.com/GvSUpG8.png" alt=""></p>
<h2 id="四-管道-过滤器模式"><a href="#四-管道-过滤器模式" class="headerlink" title="四. 管道-过滤器模式"></a>四. 管道-过滤器模式</h2><p>此模式可用于构造生成和处理数据流的系统。每个处理步骤都封装在一个过滤器组件内。要处理的数据是通过管道传递的。这些管道可以用于缓冲或用于同步。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>编译器。连续的过滤器执行词法分析、解析、语义分析和代码生成</li>
<li>生物信息学的工作流</li>
</ul>
<p><img src="https://i.imgur.com/tl5aOmU.png" alt=""></p>
<h2 id="五-代理模式"><a href="#五-代理模式" class="headerlink" title="五. 代理模式"></a>五. 代理模式</h2><p>此模式用于构造具有解耦组件的分布式系统。这些组件可以通过远程服务调用彼此交互。代理组件负责组件之间的通信协调。</p>
<p>服务器将其功能(服务和特征)发布给代理。客户端从代理请求服务，然后代理将客户端重定向到其注册中心的适当服务。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>消息代理软件，如Apache ActiveMQ，Apache Kafka，RabbitMQ和JBoss Messaging</li>
</ul>
<p><img src="https://i.imgur.com/vlIi8vu.png" alt=""></p>
<h2 id="六-点对点模式"><a href="#六-点对点模式" class="headerlink" title="六. 点对点模式"></a>六. 点对点模式</h2><p>在这种模式中，单个组件被称为对等点。对等点可以作为客户端，从其他对等点请求服务，作为服务器，为其他对等点提供服务。对等点可以充当客户端或服务器或两者的角色，并且可以随时间动态地更改其角色。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>像Gnutella和G2这样的文件共享网络</li>
<li>多媒体协议，如P2PTV和PDTP</li>
<li>像Spotify这样的专有多媒体应用程序</li>
</ul>
<p><img src="https://i.imgur.com/JDRb7w1.png" alt=""></p>
<h2 id="七-事件总线模式"><a href="#七-事件总线模式" class="headerlink" title="七. 事件总线模式"></a>七. 事件总线模式</h2><p>这种模式主要是处理事件，包括4个主要组件：事件源、事件监听器、通道和事件总线。消息源将消息发布到事件总线上的特定通道上。侦听器订阅特定的通道。侦听器会被通知消息，这些消息被发布到它们之前订阅的一个通道上。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>安卓开发</li>
<li>通知服务</li>
</ul>
<p><img src="https://i.imgur.com/iLK9CLd.png" alt=""></p>
<h2 id="八-模型-视图-控制器模式"><a href="#八-模型-视图-控制器模式" class="headerlink" title="八. 模型-视图-控制器模式"></a>八. 模型-视图-控制器模式</h2><p>这种模式，也称为MVC模式，把一个交互式应用程序划分为3个部分，</p>
<ul>
<li>模型：包含核心功能和数据</li>
<li>视图：将信息显示给用户(可以定义多个视图)</li>
<li>控制器：处理用户输入的信息</li>
</ul>
<p>这样做是为了将信息的内部表示与信息的呈现方式分离开来，并接受用户的请求。它分离了组件，并允许有效的代码重用。</p>
<p><strong>使用场景</strong>：</p>
<ul>
<li>在主要编程语言中互联网应用程序的体系架构</li>
<li>像Django和Rails这样的Web框架</li>
</ul>
<p><img src="https://i.imgur.com/kXfNV9U.png" alt=""></p>
<h2 id="九-黑板模式"><a href="#九-黑板模式" class="headerlink" title="九. 黑板模式"></a>九. 黑板模式</h2><p>这种模式对于没有确定解决方案策略的问题是有用的。黑板模式由3个主要组成部分组成。</p>
<ul>
<li>黑板——包含来自解决方案空间的对象的结构化全局内存</li>
<li>知识源——专门的模块和它们自己的表示</li>
<li>控制组件——选择、配置和执行模块</li>
</ul>
<p>所有的组件都可以访问黑板。组件可以生成添加到黑板上的新数据对象。组件在黑板上查找特定类型的数据，并通过与现有知识源的模式匹配来查找这些数据。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>语音识别</li>
<li>车辆识别和跟踪</li>
<li>蛋白质结构识别</li>
<li>声纳信号的解释</li>
</ul>
<p><img src="https://i.imgur.com/I2mjBOF.png" alt=""></p>
<h2 id="十-解释器模式"><a href="#十-解释器模式" class="headerlink" title="十. 解释器模式"></a>十. 解释器模式</h2><p>这个模式用于设计一个解释用专用语言编写的程序的组件。它主要指定如何评估程序的行数，即以特定的语言编写的句子或表达式。其基本思想是为每种语言的符号都有一个分类。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>数据库查询语言，比如SQL</li>
<li>用于描述通信协议的语言</li>
</ul>
<p><img src="https://i.imgur.com/hQsXzpc.png" alt=""></p>
<h2 id="体系架构模式的比较"><a href="#体系架构模式的比较" class="headerlink" title="体系架构模式的比较"></a>体系架构模式的比较</h2><p>下面给出的表格总结了每种体系架构模式的优缺点。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>分层模式</td>
<td>一个较低的层可以被不同的层所使用。层使标准化更容易，因为我们可以清楚地定义级别。可以在层内进行更改，而不会影响其他层。</td>
<td>不是普遍适用的。在某些情况下，某些层可能会被跳过。</td>
</tr>
<tr>
<td>客户端-服务器模式</td>
<td>很好地建立一组服务，用户可以请求他们的服务。</td>
<td>请求通常在服务器上的单独线程中处理。由于不同的客户端具有不同的表示，进程间通信会导致额外开销。</td>
</tr>
<tr>
<td>主从设备模式</td>
<td>准确性——将服务的执行委托给不同的从设备，具有不同的实现。</td>
<td>从设备是孤立的：没有共享的状态。主-从通信中的延迟可能是一个问题，例如在实时系统中。这种模式只能应用于可以分解的问题。</td>
</tr>
<tr>
<td>管道-过滤器模式</td>
<td>展示并发处理。当输入和输出由流组成时，过滤器在接收数据时开始计算。轻松添加过滤器，系统可以轻松扩展。过滤器可重复使用。</td>
<td>可以通过重新组合一组给定的过滤器来构建不同的管道。    效率受到最慢的过滤过程的限制。从一个过滤器移动到另一个过滤器时的数据转换开销。</td>
</tr>
<tr>
<td>代理模式</td>
<td>允许动态更改、添加、删除和重新定位对象，这使开发人员的发布变得透明。</td>
<td>要求对服务描述进行标准化。</td>
</tr>
<tr>
<td>点对点模式</td>
<td>支持分散式计算。对任何给定节点的故障处理具有强大的健壮性。在资源和计算能力方面具有很高的可扩展性。</td>
<td>服务质量没有保证，因为节点是自愿合作的。安全是很难得到保证的。性能取决于节点的数量。</td>
</tr>
<tr>
<td>事件总线模式</td>
<td>新的发布者、订阅者和连接可以很容易地添加。对高度分布式的应用程序有效。</td>
<td>可伸缩性可能是一个问题，因为所有消息都是通过同一事件总线进行的。</td>
</tr>
<tr>
<td>模型-视图-控制器模式</td>
<td>可以轻松地拥有同一个模型的多个视图，这些视图可以在运行时连接和断开。</td>
<td>增加复杂性。可能导致许多不必要的用户操作更新。</td>
</tr>
<tr>
<td>黑板模式</td>
<td>很容易添加新的应用程序。扩展数据空间的结构很简单。</td>
<td>修改数据空间的结构非常困难，因为所有应用程序都受到了影响。可能需要同步和访问控制。</td>
</tr>
<tr>
<td>解释器模式</td>
<td>高度动态的行为是可行的。对终端用户编程性提供好处。提高灵活性，因为替换一个解释程序很容易。</td>
<td>由于解释语言通常比编译后的语言慢，因此性能可能是一个问题。</td>
</tr>
</tbody>
</table>

                                                            <p>本文链接：
                                                                <a href="https://netlover.cn/2018/08/20/10pattern.html">
                                                                    https://netlover.cn/2018/08/20/10pattern.html
                                                                </a>
                                                            </p>
                                                            
                                        </div>
                                        <div class="article-info article-info-index">
                                                
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/架构/">架构</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/软件/">软件</a></li></ul>
	</div>


                                                    
                                                        
                                                                <div class="clearfix"></div>
                                            </div>
            </div>
            
                    
                            
                                        
</article>
  
    <article id="post-C#设计模式/C#设计模式(08) - 装饰模式(Decorator Pattern)" class="article article-type-post" itemscope itemprop="blogPost">
    
        <div class="article-meta">
            <a href="/2018/08/19/csharp-decorator-pattern.html" class="article-date">
  	<time datetime="2018-08-19T08:47:44.000Z" itemprop="datePublished">2018-08-19</time>
</a>

        </div>
        
            <div class="article-inner">
                
                    <input type="hidden" class="isFancy" />
                    
                        
                            <header class="article-header">
                                
  
    <h1 class="article-title" itemprop="name">
      <a href="/2018/08/19/csharp-decorator-pattern.html">C#设计模式(08) - 装饰模式(Decorator Pattern)</a>
    </h1>
  


                            </header>
                            <div class="article-info article-info-post">
                                    
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C-设计模式/">C#设计模式</a>
	</div>


                                    <div class="clearfix"></div>
                                </div>
                                    
                                        <div class="article-entry" itemprop="articleBody">
                                            
                                            
                                            
                                                        <h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>今天我们要讲【结构型】设计模式的第三个模式，该模式是【装饰模式】，英文名称：Decorator Pattern。我第一次看到这个名称想到的是另外一个词语“装修”，我就说说我对“装修”的理解吧，大家一定要看清楚，是“装修”,不是“装饰”。我们长大了，就要结婚，要结婚就涉及到要买房子，买的精装修或者简单装修就可以住的，暂时不谈。我们就谈谈我们购买的是毛坯房。如果我想要房子的内饰是大理石风格的，我们只要在毛坯房的基础之上用大理石风格的材料装修就可以，我们当然不可能为了要一个装修风格，就把刚刚盖好的房子拆了在重新来过。房子装修好了，我们就住了进来，很开心。过了段时间，我们发现我们的房子在冬季比较冷，于是我就想给我们的房子增加保暖的功能，装修好的房子我们可以继续居住，我们只是在房子外面加一层保护层就可以了。又过了一段时间，总是有陌生人光顾，所以我们想让房子更安全，于是我们在外墙和房顶加装安全摄像头，同时门窗也增加安全系统。随着时间的流逝，我们可能会根据我们的需求增加相应的功能，期间，我们的房子可以正常使用，加上什么设施就有了相应的功能。从这一方面来讲，“装修”和“装饰”有类似的概念，接下来就让我们看看装饰模式具体是什么吧！</p>
<h2 id="二、装饰模式的详细介绍"><a href="#二、装饰模式的详细介绍" class="headerlink" title="二、装饰模式的详细介绍"></a>二、装饰模式的详细介绍</h2><h5 id="2-1、动机（Motivate）"><a href="#2-1、动机（Motivate）" class="headerlink" title="2.1、动机（Motivate）"></a>2.1、动机（Motivate）</h5><p>在房子装修的过程中，各种功能可以相互组合，来增加房子的功用。类似的，如果我们在软件系统中，要给某个类型或者对象增加功能，如果使用“继承”的方案来写代码，就会出现子类暴涨的情况。比如：IMarbleStyle是大理石风格的一个功能，IKeepWarm是保温的一个接口定义，IHouseSecurity是房子安全的一个接口，就三个接口来说，House是我们房子，我们的房子要什么功能就实现什么接口，如果房子要的是复合功能，接口不同的组合就有不同的结果，这样就导致我们子类膨胀严重，如果需要在增加功能，子类会成指数增长。这个问题的根源在于我们“过度地使用了继承来扩展对象的功能”，由于继承为类型引入的静态特质（所谓静态特质，就是说如果想要某种功能，我们必须在编译的时候就要定义这个类，这也是强类型语言的特点。静态，就是指在编译的时候要确定的东西；动态，是指运行时确定的东西），使得这种扩展方式缺乏灵活性；并且随着子类的增多（扩展功能的增多），各种子类的组合（扩展功能的组合）会导致更多子类的膨胀（多继承）。如何使“对象功能的扩展”能够根据需要来动态（即运行时）地实现？同时避免“扩展功能的增多”带来的子类膨胀问题？从而使得任何“功能扩展变化”所导致的影响降为最低？</p>
<h5 id="2-2、意图（Intent）"><a href="#2-2、意图（Intent）" class="headerlink" title="2.2、意图（Intent）"></a>2.2、意图（Intent）</h5><blockquote>
<p>动态地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类更为灵活。　　       ——  《设计模式》GoF</p>
</blockquote>
<h5 id="2-3、结构图（Structure）"><a href="#2-3、结构图（Structure）" class="headerlink" title="2.3、结构图（Structure）"></a>2.3、结构图（Structure）</h5><p><img src="https://i.imgur.com/7r9yyti.png" alt="">       </p>
<h5 id="2-4、模式的组成"><a href="#2-4、模式的组成" class="headerlink" title="2.4、模式的组成"></a>2.4、模式的组成</h5><p>在装饰模式中的各个角色有：</p>
<ol>
<li>抽象构件角色（Component）：给出一个抽象接口，以规范准备接收附加责任的对象。</li>
<li>具体构件角色（Concrete Component）：定义一个将要接收附加责任的类。</li>
<li>装饰角色（Decorator）：持有一个构件（Component）对象的实例，并实现一个与抽象构件接口一致的接口。</li>
<li>具体装饰角色（Concrete Decorator）：负责给构件对象添加上附加的责任。</li>
</ol>
<h5 id="2-5-、装饰模式的具体代码实现"><a href="#2-5-、装饰模式的具体代码实现" class="headerlink" title="2.5 、装饰模式的具体代码实现"></a>2.5 、装饰模式的具体代码实现</h5><p>刚开始一看这个“装饰模式”是有点不太好理解，既然这个模式是面向对象的设计模式，那在现实生活中一定有事例和其对应，其实这种例子也不少，大家好好的挖掘吧，也可以提高我们对面向对象的理解。我继续拿盖房子来说事吧。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">namespace 装饰模式的实现</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 该抽象类就是房子抽象接口的定义，该类型就相当于是Component类型，是饺子馅，需要装饰的，需要包装的</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">House</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//房子的装修方法--该操作相当于Component类型的Operation方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Renovation</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 该抽象类就是装饰接口的定义，该类型就相当于是Decorator类型，如果需要具体的功能，可以子类化该类型</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">DecorationStrategy</span>:<span class="title">House</span> <span class="comment">//关键点之二，体现关系为Is-a，有这这个关系，装饰的类也可以继续装饰了</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="comment">//通过组合方式引用Decorator类型，该类型实施具体功能的增加</span></span><br><span class="line">        <span class="comment">//这是关键点之一，包含关系，体现为Has-a</span></span><br><span class="line">        <span class="keyword">protected</span> House _house;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过构造器注入，初始化平台实现</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="title">DecorationStrategy</span>(<span class="params">House house</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">           <span class="keyword">this</span>._house=house;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//该方法就相当于Decorator类型的Operation方法</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Renovation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">       </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(<span class="keyword">this</span>._house!=<span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>._house.Renovation();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> PatrickLiu的房子，我要按我的要求做房子，相当于ConcreteComponent类型，这就是我们具体的饺子馅，我个人比较喜欢韭菜馅</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">PatrickLiuHouse</span>:<span class="title">House</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Renovation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"装修PatrickLiu的房子"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">   <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 具有安全功能的设备，可以提供监视和报警功能，相当于ConcreteDecoratorA类型</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">HouseSecurityDecorator</span>:<span class="title">DecorationStrategy</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="title">HouseSecurityDecorator</span>(<span class="params">House house</span>):<span class="title">base</span>(<span class="params">house</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Renovation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">base</span>.Renovation();</span><br><span class="line">            Console.WriteLine(<span class="string">"增加安全系统"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 具有保温接口的材料，提供保温功能，相当于ConcreteDecoratorB类型</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">KeepWarmDecorator</span>:<span class="title">DecorationStrategy</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span>  <span class="title">KeepWarmDecorator</span>(<span class="params">House house</span>):<span class="title">base</span>(<span class="params">house</span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Renovation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">base</span>.Renovation();</span><br><span class="line">            Console.WriteLine(<span class="string">"增加保温的功能"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="comment">//这就是我们的饺子馅，需要装饰的房子</span></span><br><span class="line">         House myselfHouse=<span class="keyword">new</span> PatrickLiuHouse();</span><br><span class="line"></span><br><span class="line">         DecorationStrategy securityHouse=<span class="keyword">new</span> HouseSecurityDecorator(myselfHouse);</span><br><span class="line">         securityHouse.Renovation();</span><br><span class="line">         <span class="comment">//房子就有了安全系统了</span></span><br><span class="line"></span><br><span class="line">         <span class="comment">//如果我既要安全系统又要保暖呢，继续装饰就行</span></span><br><span class="line">         DecorationStrategy securityAndWarmHouse=<span class="keyword">new</span> HouseSecurityDecorator(securityHouse);</span><br><span class="line">         securityAndWarmHouse.Renovation();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写了很多备注，大家好好体会一下，里面有两个关键点，仔细把握。</p>
<h2 id="三、装饰模式的实现要点："><a href="#三、装饰模式的实现要点：" class="headerlink" title="三、装饰模式的实现要点："></a>三、装饰模式的实现要点：</h2><ol>
<li>通过采用组合、而非继承的手法，Decorator模式实现了在运行时动态地扩展对象功能的能力，而且可以根据需要扩展多个功能。避免了单独使用继承带来的“灵活性差”和“多子类衍生问题”。</li>
<li>Component类在Decorator模式中充当抽象接口的角色，不应该去实现具体的行为。而且Decorator类对于Component类应该透明——换言之Component类无需知道Decorator类，Decorator类是从外部来扩展Component类的功能。</li>
<li>Decorator类在接口上表现为is-a Component的继承关系，即Decorator类继承了Component类所具有的接口。但在实现上又表现为has-a Component的组合关系，即Decorator类又使用了另外一个Component类。我们可以使用一个或者多个Decorator对象来“装饰”一个Component对象，且装饰后的对象仍然是一个Component对象。</li>
<li>Decorator模式并非解决“多子类衍生的多继承”问题，Decorator模式应用的要点在于解决“主体类在多个方向上的扩展功能”——是为“装饰”的含义。</li>
</ol>
<p><strong>装饰模式的优点：</strong></p>
<ol>
<li>把抽象接口与其实现解耦。</li>
<li>抽象和实现可以独立扩展，不会影响到对方。</li>
<li>实现细节对客户透明，对用于隐藏了具体实现细节。</li>
</ol>
<p><strong>装饰模式的缺点：</strong></p>
<ol>
<li>增加了系统的复杂度</li>
</ol>
<p><strong>在以下情况下应当使用桥接模式：</strong></p>
<ol>
<li>如果一个系统需要在构件的抽象化角色和具体化角色之间添加更多的灵活性，避免在两个层次之间建立静态的联系。</li>
<li>设计要求实现化角色的任何改变不应当影响客户端，或者实现化角色的改变对客户端是完全透明的。</li>
<li>需要跨越多个平台的图形和窗口系统上。</li>
<li>一个类存在两个独立变化的维度，且两个维度都需要进行扩展。</li>
</ol>
<h2 id="四、-NET-中装饰模式的实现"><a href="#四、-NET-中装饰模式的实现" class="headerlink" title="四、.NET 中装饰模式的实现"></a>四、.NET 中装饰模式的实现</h2><p>在Net框架中，有一个类型很明显的使用了“装饰模式”，这个类型就是Stream。Stream类型是一个抽象接口，它在System.IO命名空间里面，它其实就是Component。FileStream、NetworkStream、MemoryStream都是实体类ConcreteComponent。右边的BufferedStream、CryptoStream是装饰对象，它们都是继承了Stream接口的。</p>
<p>如图：</p>
<p><img src="https://i.imgur.com/Gn6vO9d.png" alt="">      </p>
<p>Stream就相当于Component，定义装饰的对象，FileStream就是要装饰的对象，BufferedStream是装饰对象。我们看看BufferedStream的定义，部分定义了。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">BufferedStream</span> : <span class="title">Stream</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">int</span> _DefaultBufferSize = <span class="number">4096</span>;</span><br><span class="line"> </span><br><span class="line">	<span class="keyword">private</span> Stream _stream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结构很简单，对比结构图看吧，没什么可说的了。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>今天的文章就写到这里了，总结一下我对这个模式的看法，这个模式有点像包饺子，ConcreteComponent其实是饺子馅，Decorator就像饺子皮一样，包什么皮就有什么的样子，皮和皮也可以嵌套，当然我们生活中的饺子只是包一层。其实手机也是一个装饰模式使用的好例子，以前我们的手机只是接打电话，然后可以发短信和彩信，我在装饰一个就可以拍照了。我们现在的手机功能很丰富，其结果也类似装饰的结果。随着社会的进步，技术发展，模块化的手机也出现了，其设计原理也和“装饰模式”就更接近了。不光手机，还有我们身边其他很多家用电器也有类似的发展经历，我们努力发现生活中的真理吧，然后再在软件环境中慢慢体会吧。</p>

                                                            <p>本文链接：
                                                                <a href="https://netlover.cn/2018/08/19/csharp-decorator-pattern.html">
                                                                    https://netlover.cn/2018/08/19/csharp-decorator-pattern.html
                                                                </a>
                                                            </p>
                                                            
                                        </div>
                                        <div class="article-info article-info-index">
                                                
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Decorator-Pattern/">Decorator Pattern</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/装饰模式/">装饰模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
	</div>


                                                    
                                                        
                                                                <div class="clearfix"></div>
                                            </div>
            </div>
            
                    
                            
                                        
</article>
  
    <article id="post-C#设计模式/C#设计模式(06) - 适配器模式(Adapter Pattern)" class="article article-type-post" itemscope itemprop="blogPost">
    
        <div class="article-meta">
            <a href="/2018/08/19/csharp-adapter-pattern.html" class="article-date">
  	<time datetime="2018-08-19T03:47:44.000Z" itemprop="datePublished">2018-08-19</time>
</a>

        </div>
        
            <div class="article-inner">
                
                    <input type="hidden" class="isFancy" />
                    
                        
                            <header class="article-header">
                                
  
    <h1 class="article-title" itemprop="name">
      <a href="/2018/08/19/csharp-adapter-pattern.html">C#设计模式(06) - 适配器模式(Adapter Pattern)</a>
    </h1>
  


                            </header>
                            <div class="article-info article-info-post">
                                    
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C-设计模式/">C#设计模式</a>
	</div>


                                    <div class="clearfix"></div>
                                </div>
                                    
                                        <div class="article-entry" itemprop="articleBody">
                                            
                                            
                                            
                                                        <h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>从今天开始我们开始讲【结构型】设计模式，【结构型】设计模式有如下几种：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。【创建型】的设计模式解决的是对象创建的问题，那【结构型】设计模式解决的是类和对象的组合关系的问题。今天我们就开始讲【结构型】设计模式里面的第一个设计模式，中文名称：适配器模式，英文名称：Adapter Pattern。说起这个模式其实很简单，在现实生活中也有很多实例，比如：我们手机的充电器，充电器的接头，有的是把两相电转换为三相电的，当然也有把三相电转换成两相电的。我们经常使用笔记本电脑，笔记本电脑的工作电压和我们家里照明电压是不一致的，当然也就需要充电器把照明电压转换成笔记本的工作电压，只有这样笔记本电脑才可以正常工作。太多了，就不一一列举了。我们只要记住一点，适配就是转换，把不能在一起工作的两样东西通过转换，让他们可以在一起工作。</p>
<h2 id="二、适配器模式的详细介绍"><a href="#二、适配器模式的详细介绍" class="headerlink" title="二、适配器模式的详细介绍"></a>二、适配器模式的详细介绍</h2><h5 id="2-1、动机（Motivate）"><a href="#2-1、动机（Motivate）" class="headerlink" title="2.1、动机（Motivate）"></a>2.1、动机（Motivate）</h5><p>在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口是这些现存对象所不满足的。如何应对这种“迁移的变化”？如何既能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？</p>
<h5 id="2-2、意图（Intent）"><a href="#2-2、意图（Intent）" class="headerlink" title="2.2、意图（Intent）"></a>2.2、意图（Intent）</h5><p>将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。                                                                   –《设计模式》Gof</p>
<h5 id="2-3、结构图（Structure）"><a href="#2-3、结构图（Structure）" class="headerlink" title="2.3、结构图（Structure）"></a>2.3、结构图（Structure）</h5><p>适配器有两种结构</p>
<p>1、-对象适配器（更常用）</p>
<p><img src="https://i.imgur.com/ift5FAR.png" alt=""></p>
<p>对象适配器使用的是对象组合的方案，它的Adapter核Adaptee的关系是组合关系。</p>
<p>OO中优先使用组合模式，组合模式不适用再考虑继承。因为组合模式更加松耦合，而继承是紧耦合的，父类的任何改动都要导致子类的改动。</p>
<p>2、-类适配器</p>
<p><img src="https://i.imgur.com/SJK6dNV.png" alt="">        </p>
<h5 id="2-4、模式的组成"><a href="#2-4、模式的组成" class="headerlink" title="2.4、模式的组成"></a>2.4、模式的组成</h5><p>可以看出，在适配器模式的结构图有以下角色：</p>
<ol>
<li>目标角色（Target）：定义Client使用的与特定领域相关的接口。</li>
<li>客户角色（Client）：与符合Target接口的对象协同。</li>
<li>被适配角色（Adaptee)：定义一个已经存在并已经使用的接口，这个接口需要适配。</li>
<li>适配器角色（Adapte) ：适配器模式的核心。它将对被适配Adaptee角色已有的接口转换为目标角色Target匹配的接口。对Adaptee的接口与Target接口进行适配.</li>
</ol>
<h5 id="2-5-适配器模式的具体实现"><a href="#2-5-适配器模式的具体实现" class="headerlink" title="2.5 适配器模式的具体实现"></a>2.5 适配器模式的具体实现</h5><p>由于适配器模式有两种实现结构，今天我们针对每种都实现了自己的方式。</p>
<p><strong>1、对象的是适配器模式实现</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">namespace 对象的适配器模式</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span>家里只有两个孔的插座，也懒得买插线板了，还要花钱，但是我的手机是一个有3个小柱子的插头，明显直接搞不定，那就适配吧</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span><span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//好了，现在就可以给手机充电了</span></span><br><span class="line">            TwoHoleTarget homeTwoHole = <span class="keyword">new</span> ThreeToTwoAdapter();</span><br><span class="line">            homeTwoHole.Request();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 我家只有2个孔的插座，也就是适配器模式中的目标(Target)角色，这里可以写成抽象类或者接口</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TwoHoleTarget</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 客户端需要的方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Request</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"两孔的充电器可以使用"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 手机充电器是有3个柱子的插头，源角色——需要适配的类（Adaptee）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ThreeHoleAdaptee</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificRequest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"我是3个孔的插头也可以使用了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 适配器类，TwoHole这个对象写成接口或者抽象类更好，面向接口编程嘛</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ThreeToTwoAdapter</span> : <span class="title">TwoHoleTarget</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 引用两个孔插头的实例,从而将客户端与TwoHole联系起来</span></span><br><span class="line">        <span class="keyword">private</span> ThreeHoleAdaptee threeHoleAdaptee = <span class="keyword">new</span> ThreeHoleAdaptee();</span><br><span class="line">        <span class="comment">//这里可以继续增加适配的对象。。</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 实现2个孔插头接口方法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Request</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//可以做具体的转换工作</span></span><br><span class="line">            threeHoleAdaptee.SpecificRequest();</span><br><span class="line">            <span class="comment">//可以做具体的转换工作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、类的适配器模式实现</strong></p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">namespace 设计模式之适配器模式</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 这里手机充电器为例，我们的家的插座是两相电的，但是手机的插座接头是三相电的</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//好了，现在可以充电了</span></span><br><span class="line">            ITwoHoleTarget change = <span class="keyword">new</span> ThreeToTwoAdapter();</span><br><span class="line">            change.Request();</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 我家只有2个孔的插座，也就是适配器模式中的目标角色（Target），这里只能是接口，也是类适配器的限制</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ITwoHoleTarget</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">Request</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 3个孔的插头，源角色——需要适配的类（Adaptee）</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">ThreeHoleAdaptee</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificRequest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"我是三个孔的插头"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 适配器类，接口要放在类的后面，在此无法适配更多的对象，这是类适配器的不足</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    public class ThreeToTwoAdapter:ThreeHoleAdaptee,ITwoHoleTarget</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 实现2个孔插头接口方法</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 调用3个孔插头方法</span></span><br><span class="line">            <span class="keyword">this</span>.SpecificRequest();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码都很简答，谁都可以看得懂，也有详细的备注。</p>
<h2 id="三、适配器模式的实现要点："><a href="#三、适配器模式的实现要点：" class="headerlink" title="三、适配器模式的实现要点："></a>三、适配器模式的实现要点：</h2><ol>
<li>Adapter模式主要应用于“希望复用一些现存的类，但是接口又与复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用。</li>
<li>GoF23定义了两种Adapter模式的实现结构：对象适配器和类适配器。类适配器采用“多继承”的实现方式，在C#语言中，如果被适配角色是类，Target的实现只能是接口，因为C#语言只支持接口的多继承的特性。在C#语言中类适配器也很难支持适配多个对象的情况，同时也会带来了不良的高耦合和违反类的职责单一的原则，所以一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神，对适配的对象也没限制，可以一个，也可以多个，但是，使得重定义Adaptee的行为较困难，这就需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身。Adapter模式可以实现的非常灵活，不必拘泥于GoF23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的。</li>
<li>Adapter模式本身要求我们尽可能地使用“面向接口的编程”风格，这样才能在后期很方便地适配。</li>
</ol>
<p>适配器模式用来解决现有对象与客户端期待接口不一致的问题，下面详细总结下适配器两种形式的优缺点。</p>
<p><strong>类的适配器模式：</strong></p>
<p>优点：</p>
<ol>
<li>可以在不修改原有代码的基础上来复用现有类，很好地符合 “开闭原则”</li>
<li>可以重新定义Adaptee(被适配的类)的部分行为，因为在类适配器模式中，Adapter是Adaptee的子类</li>
<li>仅仅引入一个对象，并不需要额外的字段来引用Adaptee实例（这个即是优点也是缺点）。</li>
</ol>
<p>缺点：</p>
<ol>
<li>用一个具体的Adapter类对Adaptee和Target进行匹配，当如果想要匹配一个类以及所有它的子类时，类的适配器模式就不能胜任了。因为类的适配器模式中没有引入Adaptee的实例，光调用this.SpecificRequest方法并不能去调用它对应子类的SpecificRequest方法。</li>
<li>采用了 “多继承”的实现方式，带来了不良的高耦合。</li>
</ol>
<p><strong>对象的适配器模式</strong></p>
<p>优点：</p>
<ol>
<li>可以在不修改原有代码的基础上来复用现有类，很好地符合 “开闭原则”（这点是两种实现方式都具有的）</li>
<li>采用 “对象组合”的方式，更符合松耦合。</li>
</ol>
<p>缺点：</p>
<ol>
<li>使得重定义Adaptee的行为较困难，这就需要生成Adaptee的子类并且使得Adapter引用这个子类而不是引用Adaptee本身。</li>
</ol>
<p><strong>适配器模式使用的场景：</strong></p>
<ol>
<li>系统需要复用现有类，而该类的接口不符合系统的需求</li>
<li>想要建立一个可重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li>
<li>对于对象适配器模式，在设计里需要改变多个已有子类的接口，如果使用类的适配器模式，就要针对每一个子类做一个适配器，而这不太实际。</li>
</ol>
<h2 id="四、-NET-中适配器模式的实现"><a href="#四、-NET-中适配器模式的实现" class="headerlink" title="四、.NET 中适配器模式的实现"></a>四、.NET 中适配器模式的实现</h2><p>说道适配器模式在Net中的实现就很多了，比如：System.IO里面的很多类都有适配器的影子，当我们操作文件的时候，其实里面调用了COM的接口实现。以下两点也是适配器使用的案例：</p>
<p>1.在.NET中复用COM对象：</p>
<p>COM对象不符合.NET对象的接口，使用tlbimp.exe来创建一个Runtime Callable Wrapper（RCW）以使其符合.NET对象的接口，COM Interop就好像是COM和.NET之间的一座桥梁。</p>
<p>2..NET数据访问类（Adapter变体）：</p>
<p>各种数据库并没有提供DataSet接口，使用DbDataAdapter可以将任何个数据库访问/存取适配到一个DataSet对象上，DbDataAdapter在数据库和DataSet之间做了很好的适配。当然还有SqlDataAdapter类型了，针对微软SqlServer类型的数据库在和DataSet之间进行适配。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>今天的文章就写到这里了，在结束今天写作之前，有一句话还是要说的，虽然以前说过。每种设计模式都有自己的适用场景，它是为了解决一类问题，没有所谓的缺点，没有一种设计模式可以解决所有情况的。我们使用设计模式的态度是通过不断地重构来使用模式，不要一上来就使用设计模式，为了模式而模式。如果软件没有需求的变化，我们不使用模式都没有问题。遇到问题，我们就按着常规来写，有了需求变化，然后我们去抽象，了解使用的场景，然后在选择合适的设计模式。</p>

                                                            <p>本文链接：
                                                                <a href="https://netlover.cn/2018/08/19/csharp-adapter-pattern.html">
                                                                    https://netlover.cn/2018/08/19/csharp-adapter-pattern.html
                                                                </a>
                                                            </p>
                                                            
                                        </div>
                                        <div class="article-info article-info-index">
                                                
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Adapter-Pattern/">Adapter Pattern</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/适配器模式/">适配器模式</a></li></ul>
	</div>


                                                    
                                                        
                                                                <div class="clearfix"></div>
                                            </div>
            </div>
            
                    
                            
                                        
</article>
  
    <article id="post-C#设计模式/C#设计模式(10) - 外观模式(Facade Pattern)" class="article article-type-post" itemscope itemprop="blogPost">
    
        <div class="article-meta">
            <a href="/2018/08/19/csharp-facade-pattern.html" class="article-date">
  	<time datetime="2018-08-19T03:45:44.000Z" itemprop="datePublished">2018-08-19</time>
</a>

        </div>
        
            <div class="article-inner">
                
                    <input type="hidden" class="isFancy" />
                    
                        
                            <header class="article-header">
                                
  
    <h1 class="article-title" itemprop="name">
      <a href="/2018/08/19/csharp-facade-pattern.html">C#设计模式(10) - 外观模式(Facade Pattern)</a>
    </h1>
  


                            </header>
                            <div class="article-info article-info-post">
                                    
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C-设计模式/">C#设计模式</a>
	</div>


                                    <div class="clearfix"></div>
                                </div>
                                    
                                        <div class="article-entry" itemprop="articleBody">
                                            
                                            
                                            
                                                        <h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>快12点半了，要开始今天的写作了。很快，转眼设计模式已经写了十个了，今天我们要讲【结构型】设计模式的第五个模式，该模式是【外观模式】，英文名称是：Facade Pattern。我们先从名字上来理解一下“外观模式”。我看到了“外观”这个词语，就想到了“外表”这个词语，两者有着很相近的意思。就拿谈恋爱来说，“外表”很重要，如果第一眼看着很舒服、有眼缘，那就有交往下去的可能。如果长的“三寸钉、枯树皮”，估计就够呛了。在这方面，“外观”和“外表”有着相同的作用。在软件系统中，要完成一个功能，需要很多接口调用，不仅增加了开发难度，也增加了调试成本和维护的复杂度。不如我们把这些接口再封装一次，给一个很好的“外观”，让使用者使用更方便，只需调用一个接口，就可以完成以前调用多个接口的来完成任务，这就方便了。这个模式很简单，大家很容易理解，可能大家在编码的过程中已经不止一次使用过该模式了，只是不知道名字罢了。现实生活中这样的例子很多，举不胜举，来一幅图，大家看看就明白了。</p>
<p>图一：</p>
<p><img src="https://i.imgur.com/nVKpUIR.png" alt="">        </p>
<h2 id="二、外观模式的详细介绍"><a href="#二、外观模式的详细介绍" class="headerlink" title="二、外观模式的详细介绍"></a>二、外观模式的详细介绍</h2><h5 id="2-1、动机（Motivate）"><a href="#2-1、动机（Motivate）" class="headerlink" title="2.1、动机（Motivate）"></a>2.1、动机（Motivate）</h5><p>在软件系统开发的过程中，当组件的客户（即外部接口，或客户程序）和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦？</p>
<h5 id="2-2、意图（Intent）"><a href="#2-2、意图（Intent）" class="headerlink" title="2.2、意图（Intent）"></a>2.2、意图（Intent）</h5><blockquote>
<p>为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。　　　　　　——《设计模式》GoF</p>
</blockquote>
<h5 id="2-3、结构图（Structure）"><a href="#2-3、结构图（Structure）" class="headerlink" title="2.3、结构图（Structure）"></a>2.3、结构图（Structure）</h5><p><img src="https://i.imgur.com/xmDk6PB.png" alt="">       </p>
<h5 id="2-4、模式的组成"><a href="#2-4、模式的组成" class="headerlink" title="2.4、模式的组成"></a>2.4、模式的组成</h5><p><strong>外观模式包含如下两个角色：</strong></p>
<ol>
<li>外观角色（Facade）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</li>
<li>子系统角色（SubSystem）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</li>
</ol>
<h5 id="2-5、外观模式的具体实现"><a href="#2-5、外观模式的具体实现" class="headerlink" title="2.5、外观模式的具体实现"></a>2.5、外观模式的具体实现</h5><p>马上就到“双十一”了，人们又开始疯狂的购买了。其实购买的过程很复杂，但是我们在购买的过程只需要选择自己喜欢的商品，也可以加入购物车，最后点击付款就完成了。其实这个过程没有那么简单。我们下面就模仿一下购买的过程吧。</p>
<p>购买过程有几点必须要做的事情：</p>
<ol>
<li>身份验证安全，没有认证是无效用户。</li>
<li>系统安全，检查系统环境，防止注入、跨站和伪造等攻击</li>
<li>网银安全，检查付款地址的有效性，检查网关是否正常</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">namespace 外观模式的实现</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 不使用外观模式的情况</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 此时客户端与三个子系统都发送了耦合，使得客户端程序依赖与子系统</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 为了解决这样的问题，我们可以使用外观模式来为所有子系统设计一个统一的接口</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 客户端只需要调用外观类中的方法就可以了，简化了客户端的操作</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 从而让客户和子系统之间避免了紧耦合</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            SystemFacade facade=<span class="keyword">new</span> SystemFacade();</span><br><span class="line">            facade.Buy();</span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 身份认证子系统A</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AuthoriationSystemA</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodA</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"执行身份认证"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 系统安全子系统B</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SecuritySystemB</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodB</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"执行系统安全检查"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 网银安全子系统C</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NetBankSystemC</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">MethodC</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"执行网银安全检测"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//更高层的Facade</span></span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SystemFacade</span></span><br><span class="line">   &#123;</span><br><span class="line">      <span class="keyword">private</span> AuthoriationSystemA auth;</span><br><span class="line">      <span class="keyword">private</span> SecuritySystemB security;</span><br><span class="line">      <span class="keyword">private</span> NetBankSystemC netbank;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="title">SystemFacade</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         auth=<span class="keyword">new</span> AuthoriationSystemA();</span><br><span class="line">         security=<span class="keyword">new</span> SecuritySystemB();</span><br><span class="line">         netbank=<span class="keyword">new</span> NetBankSystemC();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Buy</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">          auth.MethodA();<span class="comment">//身份认证子系统</span></span><br><span class="line">          security.MethodB();<span class="comment">//系统安全子系统</span></span><br><span class="line">          netbank.MethodC();<span class="comment">//网银安全子系统</span></span><br><span class="line"></span><br><span class="line">          Console.WriteLine(<span class="string">"我已经成功购买了！"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模式很简单，就话不多说了。</p>
<h2 id="三、外观模式的实现要点："><a href="#三、外观模式的实现要点：" class="headerlink" title="三、外观模式的实现要点："></a>三、外观模式的实现要点：</h2><p>1、一个系统可以有几个门面类</p>
<p>在门面模式中，通常只需要一个门面类，并且此门面类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只有一个门面类，而仅仅是说对每一个子系统只有一个门面类。或者说，如果一个系统有好几个子系统的话，每一个子系统都有一个门面类，整个系统可以有数个门面类。</p>
<p>2、为子系统增加新行为</p>
<p>初学者往往以为通过继承一个门面类便可在子系统中加入新的行为，这是错误的。门面模式的用意是为子系统提供一个集中化和简化的沟通管道，而不能向子系统加入新的行为。比如医院中的接待员并不是医护人员，接待员并不能为病人提供医疗服务。</p>
<p>3、Facade有助于建立层次结构的系统，实现了子系统与客户之间的松耦合关系，子系统内部的功能组件往往是紧耦合的。松耦合关系使得子系统的组件变化不会影响到它的客户。Facade消除了复杂的循环依赖关系。这一点在客户程序与子系统分别实现的时候格外重要。</p>
<p>4、从客户程序的角度来看，Facade模式不仅简化了整个组件系统的接口，同时对于组件内部与外部客户程序来说，从某种程度上也达到了一种“解耦”的效果——内部子系统的任何变化不会影响到Facade接口的变化。</p>
<p><strong>外观模式的优点：</strong></p>
<ol>
<li>外观模式对客户屏蔽了子系统组件，从而简化了接口，减少了客户处理的对象数目并使子系统的使用更加简单。</li>
<li>外观模式实现了子系统与客户之间的松耦合关系，而子系统内部的功能组件是紧耦合的。松耦合使得子系统的组件变化不会影响到它的客户。</li>
</ol>
<p><strong>外观模式的缺点：</strong></p>
<ol>
<li>如果增加新的子系统可能需要修改外观类或客户端的源代码，这样就违背了”开——闭原则“（不过这点也是不可避免）。</li>
</ol>
<p><strong>在以下情况下可以考虑使用外观模式：</strong></p>
<ol>
<li>外一个复杂的子系统提供一个简单的接口</li>
<li>提供子系统的独立性</li>
<li>在层次化结构中，可以使用外观模式定义系统中每一层的入口。其中三层架构就是这样的一个例子。</li>
</ol>
<h2 id="四、-NET-中外观模式的实现"><a href="#四、-NET-中外观模式的实现" class="headerlink" title="四、.NET 中外观模式的实现"></a>四、.NET 中外观模式的实现</h2><p>外观模式在FCL里面运用还是很多的，多数情况是单个类的情况，在Asp.Net里面，有很多复合控件，比如：Login控件，可以登录，可以认证，可以保存登录用户信息。其实，外观模式更多的是应用在业务系统当中，效果更好。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>这个模式很简单，就不说了，就稍微做一下小结。Facade设计模式更注重从架构的层次去看整个系统，而不是单个类的层次。Facade很多时候更是一种架构设计模式。注意区分Facade模式、Adapter模式、Bridge模式与Decorator模式：</p>
<ul>
<li>Facade模式注重简化接口</li>
<li>Adapter模式注重转换接口</li>
<li>Bridge模式注重分离接口（抽象）与其实现</li>
<li>Decorator模式注重稳定接口的前提下为对象扩展功能</li>
</ul>

                                                            <p>本文链接：
                                                                <a href="https://netlover.cn/2018/08/19/csharp-facade-pattern.html">
                                                                    https://netlover.cn/2018/08/19/csharp-facade-pattern.html
                                                                </a>
                                                            </p>
                                                            
                                        </div>
                                        <div class="article-info article-info-index">
                                                
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Facade-Pattern/">Facade Pattern</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/外观模式/">外观模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
	</div>


                                                    
                                                        
                                                                <div class="clearfix"></div>
                                            </div>
            </div>
            
                    
                            
                                        
</article>
  
    <article id="post-C#设计模式/C#设计模式(09) - 组合模式(Composite Pattern)" class="article article-type-post" itemscope itemprop="blogPost">
    
        <div class="article-meta">
            <a href="/2018/08/19/csharp-composite-pattern.html" class="article-date">
  	<time datetime="2018-08-19T03:10:44.000Z" itemprop="datePublished">2018-08-19</time>
</a>

        </div>
        
            <div class="article-inner">
                
                    <input type="hidden" class="isFancy" />
                    
                        
                            <header class="article-header">
                                
  
    <h1 class="article-title" itemprop="name">
      <a href="/2018/08/19/csharp-composite-pattern.html">C#设计模式(09) - 组合模式(Composite Pattern)</a>
    </h1>
  


                            </header>
                            <div class="article-info article-info-post">
                                    
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C-设计模式/">C#设计模式</a>
	</div>


                                    <div class="clearfix"></div>
                                </div>
                                    
                                        <div class="article-entry" itemprop="articleBody">
                                            
                                            
                                            
                                                        <h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>今天我们要讲【结构型】设计模式的第四个模式，该模式是【组合模式】，英文名称是：Composite Pattern。当我们谈到这个模式的时候，有一个物件和这个模式很像，也符合这个模式要表达的意思，那就是“俄罗斯套娃”。“俄罗斯套娃”就是大的瓷器娃娃里面装着一个小的瓷器娃娃，小的瓷器娃娃里面再装着更小的瓷器娃娃，直到最后一个不能再装更小的瓷器娃娃的那个瓷器娃娃为止（有点绕，下面我会配图，一看就明白）。在我们的操作系统中有文件夹的概念，文件夹可以包含文件夹，可以嵌套多层，最里面包含的是文件，这个概念和“俄罗斯套娃”很像。当然还有很多的例子，例如我们使用系统的时候，会使用到“系统菜单”，这个东西是树形结构。这些例子包含的这些东西或者说是对象，可以分为两类，一类是：容器对象，可以包含其他的子对象；另一类是：叶子对象，这类对象是不能在包含其他对象的对象了。在软件设计中，我们该怎么处理这种情况呢？是每类对象分别对待，还是提供一个统一的操作方式呢。组合模式给我们提供了一种解决此类问题的一个途径，接下来我们就好好的介绍一下“组合模式”吧。</p>
<p><img src="https://i.imgur.com/PgQsMqp.jpg" alt="">       </p>
<h2 id="二、组合模式的详细介绍"><a href="#二、组合模式的详细介绍" class="headerlink" title="二、组合模式的详细介绍"></a>二、组合模式的详细介绍</h2><h5 id="2-1、动机（Motivate）"><a href="#2-1、动机（Motivate）" class="headerlink" title="2.1、动机（Motivate）"></a>2.1、动机（Motivate）</h5><p>客户代码过多地依赖于对象容器（对象容器是对象的容器，细细评味）复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等方面的弊端。如何将“客户代码与复杂的对象容器结构”解耦？如何让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器？</p>
<h5 id="2-2、意图（Intent）"><a href="#2-2、意图（Intent）" class="headerlink" title="2.2、意图（Intent）"></a>2.2、意图（Intent）</h5><blockquote>
<p>将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。　　       ——  《设计模式》GoF</p>
</blockquote>
<h5 id="2-3、结构图（Structure）"><a href="#2-3、结构图（Structure）" class="headerlink" title="2.3、结构图（Structure）"></a>2.3、结构图（Structure）</h5><p><img src="https://i.imgur.com/Ki5DiZJ.png" alt="">      </p>
<h5 id="2-4、模式的组成"><a href="#2-4、模式的组成" class="headerlink" title="2.4、模式的组成"></a>2.4、模式的组成</h5><p>组合模式中涉及到三个角色：</p>
<ol>
<li>抽象构件角色（Component）：这是一个抽象角色，它给参加组合的对象定义出了公共的接口及默认行为，可以用来管理所有的子对象（在透明式的组合模式是这样的）。在安全式的组合模式里，构件角色并不定义出管理子对象的方法，这一定义由树枝结构对象给出。</li>
<li>树叶构件角色（Leaf）：树叶对象是没有下级子对象的对象，定义出参加组合的原始对象的行为。（原始对象的行为可以理解为没有容器对象管理子对象的方法，或者 【原始对象行为】+【管理子对象的行为（Add，Remove等）】=面对客户代码的接口行为集合）</li>
<li>树枝构件角色（Composite）：代表参加组合的有下级子对象的对象，树枝对象给出所有管理子对象的方法实现，如Add、Remove等。</li>
</ol>
<p>组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。</p>
<h5 id="2-5、组合模式的具体代码实现"><a href="#2-5、组合模式的具体代码实现" class="headerlink" title="2.5、组合模式的具体代码实现"></a>2.5、组合模式的具体代码实现</h5><p>组合模式有两种实现方式，一种是：透明式的组合模式，另外一种是：安全式的组合模式。在这里我就详细说一下何为“透明式”，何为“安全式”。所谓透明式是指“抽象构件角色”定义的接口行为集合包含两个部分，一部分是叶子对象本身所包含的行为（比如Operation），另外一部分是容器对象本身所包含的管理子对象的行为(Add,Remove)。这个抽象构件必须同时包含这两类对象所有的行为，客户端代码才会透明的使用，无论调用容器对象还是叶子对象，接口方法都是一样的，这就是透明，针对客户端代码的透明，但是也有他自己的问题，叶子对象不会包含自己的子对象，为什么要有Add,Remove等类似方法呢，调用叶子对象这样的方法可能（注意：我这里说的是可能，因为有些人会把这些方法实现为空，不做任何动作，当然也不会有异常抛出了，不要抬杠）会抛出异常，这样就不安全了，然后人们就提出了“安全式的组合模式”。所谓安全式是指“抽象构件角色”只定义叶子对象的方法，确切的说这个抽象构件只定义两类对象共有的行为，然后容器对象的方法定义在“树枝构件角色”上，这样叶子对象有叶子对象的方法，容器对象有容器对象的方法，这样责任很明确，当然调用肯定不会抛出异常了。大家可以根据自己的情况自行选择是实现为“透视式”还是“安全式”的，以下我们会针对这两种情况都有实现，具体实现如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">namespace 透明式的组合模式的实现</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 该抽象类就是文件夹抽象接口的定义，该类型就相当于是抽象构件Component类型</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Folder</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//增加文件夹或文件</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">Folder folder</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除文件夹或者文件</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">Folder folder</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开文件或者文件夹--该操作相当于Component类型的Operation方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Open</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 该Word文档类就是叶子构件的定义，该类型就相当于是Leaf类型，不能在包含子对象</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Word</span> : <span class="title">Folder</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//增加文件夹或文件</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">Folder folder</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Word文档不具有该功能"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除文件夹或者文件</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">Folder folder</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">"Word文档不具有该功能"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开文件--该操作相当于Component类型的Operation方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Open</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"打开Word文档，开始进行编辑"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> SonFolder类型就是树枝构件，由于我们使用的是“透明式”，所以Add,Remove都是从Folder类型继承下来的</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SonFolder</span> : <span class="title">Folder</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//增加文件夹或文件</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">Folder folder</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"文件或者文件夹已经增加成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除文件夹或者文件</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">Folder folder</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"文件或者文件夹已经删除成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开文件夹--该操作相当于Component类型的Operation方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Open</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"已经打开当前文件夹"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line"></span><br><span class="line">            Folder myword = <span class="keyword">new</span> Word();</span><br><span class="line"></span><br><span class="line">            myword.Open();<span class="comment">//打开文件，处理文件</span></span><br><span class="line"></span><br><span class="line">            myword.Add(<span class="keyword">new</span> SonFolder());<span class="comment">//抛出异常</span></span><br><span class="line">            myword.Remove(<span class="keyword">new</span> SonFolder());<span class="comment">//抛出异常</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Folder myfolder = <span class="keyword">new</span> SonFolder();</span><br><span class="line">            myfolder.Open();<span class="comment">//打开文件夹</span></span><br><span class="line"></span><br><span class="line">            myfolder.Add(<span class="keyword">new</span> SonFolder());<span class="comment">//成功增加文件或者文件夹</span></span><br><span class="line">            myfolder.Remove(<span class="keyword">new</span> SonFolder());<span class="comment">//成功删除文件或者文件夹</span></span><br><span class="line"></span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码就是“透明式的组合模式”实现，以下代码就是“安全式的组合模式”实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">namespace 安全式的组合模式的实现</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 该抽象类就是文件夹抽象接口的定义，该类型就相当于是抽象构件Component类型</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Folder</span> <span class="comment">//该类型少了容器对象管理子对象的方法的定义，换了地方，在树枝构件也就是SonFolder类型</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打开文件或者文件夹--该操作相当于Component类型的Operation方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Open</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 该Word文档类就是叶子构件的定义，该类型就相当于是Leaf类型，不能在包含子对象</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Word</span> : <span class="title">Folder</span>  <span class="comment">//这类型现在很干净</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//打开文件--该操作相当于Component类型的Operation方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Open</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"打开Word文档，开始进行编辑"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> SonFolder类型就是树枝构件，现在由于我们使用的是“安全式”，所以Add,Remove都是从此处开始定义的</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">SonFolder</span> : <span class="title">Folder</span> <span class="comment">//这里可以是抽象接口，可以自己根据自己的情况而定</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//增加文件夹或文件</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">Folder folder</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除文件夹或者文件</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">Folder folder</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开文件夹--该操作相当于Component类型的Operation方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Open</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"已经打开当前文件夹"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> NextFolder类型就是树枝构件的实现类</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">NextFolder</span> : <span class="title">SonFolder</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//增加文件夹或文件</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params">Folder folder</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"文件或者文件夹已经增加成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除文件夹或者文件</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Remove</span>(<span class="params">Folder folder</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"文件或者文件夹已经删除成功"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//打开文件夹--该操作相当于Component类型的Operation方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Open</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"已经打开当前文件夹"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//这是安全的组合模式</span></span><br><span class="line">            Folder myword = <span class="keyword">new</span> Word();</span><br><span class="line"></span><br><span class="line">            myword.Open();<span class="comment">//打开文件，处理文件</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            Folder myfolder = <span class="keyword">new</span> NextFolder();</span><br><span class="line">            myfolder.Open();<span class="comment">//打开文件夹</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//此处要是用增加和删除功能，需要转型的操作，否则不能使用</span></span><br><span class="line">            ((SonFolder)myfolder).Add(<span class="keyword">new</span> NextFolder());<span class="comment">//成功增加文件或者文件夹</span></span><br><span class="line">            ((SonFolder)myfolder).Remove(<span class="keyword">new</span> NextFolder());<span class="comment">//成功删除文件或者文件夹</span></span><br><span class="line"></span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个模式不是很难，仔细体会实现关键点，最重要理解模式的意图，结合结构图，大家好好体会一下。</p>
<h2 id="三、组合模式的实现要点："><a href="#三、组合模式的实现要点：" class="headerlink" title="三、组合模式的实现要点："></a>三、组合模式的实现要点：</h2><ol>
<li>Composite模式采用树形结构来实现普遍存在的对象容器，从而将“一对多”的关系转化为“一对一”的关系，使得客户代码可以一致地处理对象和对象容器，无需关心处理的是单个的对象，还是组合的对象容器。</li>
<li>将“客户代码与复杂的对象容器结构”解耦是Composite模式的核心思想，解耦之后，客户代码将与纯粹的抽象接口——而非对象容器的复杂内部实现结构——发生依赖关系，从而更能“应对变化”。</li>
<li>Composite模式中，是将“Add和Remove等和对象容器相关的方法”定义在“表示抽象对象的Component类”中，还是将其定义在“表示对象容器的Composite类”中，是一个关乎“透明性”和“安全性”的两难问题，需要仔细权衡。这里有可能违背面向对象的“单一职责原则”，但是对于这种特殊结构，这又是必须付出的代价。ASP.Net控件的实现在这方面为我们提供了一个很好的示范。</li>
<li>Composite模式在具体实现中，可以让父对象中的子对象反向追朔；如果父对象有频繁的遍历需求，可使用缓存技巧来改善效率。</li>
</ol>
<p><strong>组合模式的优点：</strong></p>
<ol>
<li>组合模式使得客户端代码可以一致地处理对象和对象容器，无需关系处理的单个对象，还是组合的对象容器。</li>
<li>将”客户代码与复杂的对象容器结构“解耦。</li>
<li>可以更容易地往组合对象中加入新的构件。</li>
</ol>
<p><strong>组合模式的缺点：</strong></p>
<ol>
<li>使得设计更加复杂。客户端需要花更多时间理清类之间的层次关系。（这个是几乎所有设计模式所面临的问题）。</li>
</ol>
<p><strong>在以下情况下应该考虑使用组合模式：</strong></p>
<ol>
<li>需要表示一个对象整体或部分的层次结构。</li>
<li>希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象。</li>
</ol>
<h2 id="四、-NET-中组合模式的实现"><a href="#四、-NET-中组合模式的实现" class="headerlink" title="四、.NET 中组合模式的实现"></a>四、.NET 中组合模式的实现</h2><p>其实组合模式在FCL里面运用还是很多的，不知道大家是不是有所感觉，这个模式大多数是运用在控件上或者是和界面操作、展示相关的操作上。这个模式在.NET 中最典型的应用就是应用与WinForms和Web的开发中，在.NET类库中，都为这两个平台提供了很多现有的控件，然而System.Windows.Forms.dll中System.Windows.Forms.Control类就应用了组合模式，因为控件包括Label、TextBox等这样的简单控件，这些控件可以理解为叶子对象，同时也包括GroupBox、DataGrid这样复合的控件或者叫容器控件，每个控件都需要调用OnPaint方法来进行控件显示，为了表示这种对象之间整体与部分的层次结构，微软把Control类的实现应用了组合模式（确切地说应用了透明式的组合模式）。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>我写文章，怎么也要3个小时，也要读上好几遍，防止有错字错句的出现。我也想把握的理解更好融进我写的文章中，但是能力有限，欢迎大家来批评指正，我也会从中收益。今天的文章就写到这里了，模式这个东西就像“独孤九剑”，不要死记硬背，要多看看别人的，多写写代码，要理解场景和意图，多写多练吧，你就有可能成为一代大侠。模式学无止境，我也是刚刚开始。</p>

                                                            <p>本文链接：
                                                                <a href="https://netlover.cn/2018/08/19/csharp-composite-pattern.html">
                                                                    https://netlover.cn/2018/08/19/csharp-composite-pattern.html
                                                                </a>
                                                            </p>
                                                            
                                        </div>
                                        <div class="article-info article-info-index">
                                                
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Composite-Pattern/">Composite Pattern</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/组合模式/">组合模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
	</div>


                                                    
                                                        
                                                                <div class="clearfix"></div>
                                            </div>
            </div>
            
                    
                            
                                        
</article>
  
    <article id="post-C#设计模式/C#设计模式(05) - 原型模式(Prototype Pattern)" class="article article-type-post" itemscope itemprop="blogPost">
    
        <div class="article-meta">
            <a href="/2018/08/18/csharp-prototype-pattern.html" class="article-date">
  	<time datetime="2018-08-18T11:47:44.000Z" itemprop="datePublished">2018-08-18</time>
</a>

        </div>
        
            <div class="article-inner">
                
                    <input type="hidden" class="isFancy" />
                    
                        
                            <header class="article-header">
                                
  
    <h1 class="article-title" itemprop="name">
      <a href="/2018/08/18/csharp-prototype-pattern.html">C#设计模式(05) - 原型模式(Prototype Pattern)</a>
    </h1>
  


                            </header>
                            <div class="article-info article-info-post">
                                    
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C-设计模式/">C#设计模式</a>
	</div>


                                    <div class="clearfix"></div>
                                </div>
                                    
                                        <div class="article-entry" itemprop="articleBody">
                                            
                                            
                                            
                                                        <h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>在开始今天的文章之前先说明一点，欢迎大家来指正。很多人说原型设计模式会节省机器内存，他们说是拷贝出来的对象，这些对象其实都是原型的复制，不会使用内存。我认为这是不对的，因为拷贝出来的每一个对象都是实际存在的，每个对象都有自己的独立内存地址，都会被GC回收。如果就浅拷贝来说，可能会公用一些字段，深拷贝是不会的，所以说原型设计模式会提高内存使用率，不一定。具体还要看当时的设计，如果拷贝出来的对象缓存了，每次使用的是缓存的拷贝对象，那就另当别论了，再说该模式本身解决的不是内存使用率的问题。</p>
<p>现在说说原型模式的要解决的问题吧，在软件系统中，当创建一个类的实例的过程很昂贵或很复杂，并且我们需要创建多个这样类的实例时，如果我们用new操作符去创建这样的类实例，这就会增加创建类的复杂度和创建过程与客户代码复杂的耦合度。如果采用工厂模式来创建这样的实例对象的话，随着产品类的不断增加，导致子类的数量不断增多，也导致了相应工厂类的增加，维护的代码维度增加了，因为有产品和工厂两个维度了，反而增加了系统复杂程度，所以在这里使用工厂模式来封装类创建过程并不合适。由于每个类实例都是相同的，这个相同指的是类型相同，但是每个实例的状态参数会有不同，如果状态数值也相同就没意义了，有一个这样的对象就可以了。当我们需要多个相同的类实例时，可以通过对原来对象拷贝一份来完成创建，这个思路正是原型模式的实现方式。</p>
<h2 id="二、原型模式的详细介绍"><a href="#二、原型模式的详细介绍" class="headerlink" title="二、原型模式的详细介绍"></a>二、原型模式的详细介绍</h2><h5 id="2-1、动机（Motivate）"><a href="#2-1、动机（Motivate）" class="headerlink" title="2.1、动机（Motivate）"></a>2.1、动机（Motivate）</h5><p>在软件系统中，经常面临着“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。如何应对这种变化？如何向“客户程序（使用这些对象的程序）”隔离出“这些易变对象”，从而使得“依赖这些易变对象的客户程序”不随着需求改变而改变？</p>
<h5 id="2-2、意图（Intent）"><a href="#2-2、意图（Intent）" class="headerlink" title="2.2、意图（Intent）"></a>2.2、意图（Intent）</h5><p>使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象。                 –《设计模式》Gof</p>
<h5 id="2-3、结构图（Structure）"><a href="#2-3、结构图（Structure）" class="headerlink" title="2.3、结构图（Structure）"></a>2.3、结构图（Structure）</h5><p><img src="https://i.imgur.com/9Kngv96.png" alt="">    </p>
<h5 id="2-4、模式的组成"><a href="#2-4、模式的组成" class="headerlink" title="2.4、模式的组成"></a>2.4、模式的组成</h5><p>可以看出，在原型模式的结构图有以下角色：</p>
<ol>
<li>原型类（Prototype）：原型类，声明一个Clone自身的接口；</li>
<li>具体原型类（ConcretePrototype）：实现一个Clone自身的操作。</li>
</ol>
<p>在原型模式中，Prototype通常提供一个包含Clone方法的接口，具体的原型ConcretePrototype使用Clone方法完成对象的创建。</p>
<h5 id="2-5-原型模式的具体实现"><a href="#2-5-原型模式的具体实现" class="headerlink" title="2.5 原型模式的具体实现"></a>2.5 原型模式的具体实现</h5><p>《大话西游之大圣娶亲》这部电影，没看过的人不多吧，里面有这样一个场景。牛魔王使用无敌牛虱大战至尊宝，至尊宝的应对之策就是，从脑后把下一撮猴毛，吹了口仙气，无数猴子猴孙现身，来大战牛魔王的无敌牛虱。至尊宝的猴子猴孙就是该原型模式的最好体现。至尊宝创建自己的一个副本，不用还要重新孕育五百年，然后出世，再学艺，最后来和老牛大战，估计黄花菜都凉了。他有3根救命猴毛，轻轻一吹，想要多少个自己就有多少个，方便，快捷。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 原型设计模式，每个具体原型是一类对象的原始对象，通过每个原型对象克隆出来的对象也可以进行设置，在原型的基础之上丰富克隆出来的对象，所以要设计好抽象原型的接口</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">namespace 设计模式之原型模式</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 客户类</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Prototype xingZheSun = <span class="keyword">new</span> XingZheSunPrototype();</span><br><span class="line">            Prototype xingZheSun2 = xingZheSun.Clone();</span><br><span class="line">            Prototype xingZheSun3 = xingZheSun.Clone();</span><br><span class="line">	</span><br><span class="line">            Prototype sunXingZhe = <span class="keyword">new</span> SunXingZhePrototype();</span><br><span class="line">            Prototype sunXingZhe2 = sunXingZhe.Clone();</span><br><span class="line">            Prototype sunXingZhe3 = sunXingZhe.Clone();</span><br><span class="line">            Prototype sunXingZhe4 = sunXingZhe.Clone();</span><br><span class="line">            Prototype sunXingZhe5 = sunXingZhe.Clone();</span><br><span class="line">	</span><br><span class="line">            <span class="comment">//1号孙行者打妖怪</span></span><br><span class="line">            sunXingZhe.Fight();</span><br><span class="line">            <span class="comment">//2号孙行者去化缘</span></span><br><span class="line">            sunXingZhe2.BegAlms();</span><br><span class="line">	</span><br><span class="line">            <span class="comment">//战斗和化缘也可以分类，比如化缘，可以分：水果类化缘，饭食类化缘；战斗可以分为：天界宠物下界成妖的战斗，自然修炼成妖的战斗，大家可以自己去想吧，原型模式还是很有用的</span></span><br><span class="line">	</span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 抽象原型，定义了原型本身所具有特征和动作，该类型就是至尊宝</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Prototype</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 战斗--保护师傅</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Fight</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="comment">// 化缘--不要饿着师傅</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BegAlms</span>(<span class="params"></span>)</span>;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 吹口仙气--变化一个自己出来</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Prototype <span class="title">Clone</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 具体原型，例如：行者孙，他只负责化斋饭食和与天界宠物下界的妖怪的战斗</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">XingZheSunPrototype</span>:<span class="title">Prototype</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 战斗--保护师傅--与自然修炼成妖的战斗</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Fight</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"腾云驾雾，各种武艺"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 化缘--不要饿着师傅--饭食类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BegAlms</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"什么都能要来"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 吹口仙气--变化一个自己出来</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Prototype <span class="title">Clone</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (XingZheSunPrototype)<span class="keyword">this</span>.MemberwiseClone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 具体原型，例如：孙行者，他只负责与自然界修炼成妖的战斗和化斋水果</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">SunXingZhePrototype</span> : <span class="title">Prototype</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 战斗--保护师傅-与天界宠物战斗</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Fight</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"腾云驾雾，各种武艺"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 化缘--不要饿着师傅---水果类</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BegAlms</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"什么都能要来"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// 吹口仙气--变化一个自己出来</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Prototype <span class="title">Clone</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (SunXingZhePrototype)<span class="keyword">this</span>.MemberwiseClone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中都有详细的注释代码，这里就不过多解释。</p>
<h2 id="三、原型模式的实现要点："><a href="#三、原型模式的实现要点：" class="headerlink" title="三、原型模式的实现要点："></a>三、原型模式的实现要点：</h2><p>Prototype模式同样用于隔离类对象的使用者和具体类型（易变类）之间的耦合关系，它同样要求这些“易变类”拥有“稳定的接口”。 </p>
<p>Prototype模式对于“如何创建易变类的实体对象”（创建型模式除了Singleton模式以外，都是用于解决创建易变类的实体对象的问题的）采用“原型克隆”的方法来做，它使得我们可以非常灵活地动态创建“拥有某些稳定接口”的新对象——所需工作仅仅是注册一个新类的对象（即原型），然后在任何需要的地方不断地Clone。 </p>
<p>Prototype模式中的Clone方法可以利用.NET中的Object类的MemberwiseClone()方法或者序列化来实现深拷贝。</p>
<p><strong>原型模式的优点：</strong></p>
<ol>
<li>原型模式向客户隐藏了创建新实例的复杂性</li>
<li>原型模式允许动态增加或较少产品类。</li>
<li>原型模式简化了实例的创建结构，工厂方法模式需要有一个与产品类等级结构相同的等级结构，而原型模式不需要这样。</li>
<li>产品类不需要事先确定产品的等级结构，因为原型模式适用于任何的等级结构</li>
</ol>
<p><strong>原型模式的缺点：</strong></p>
<ol>
<li>每个类必须配备一个克隆方法</li>
<li>配备克隆方法需要对类的功能进行通盘考虑，这对于全新的类不是很难，但对于已有的类不一定很容易，特别当一个类引用不支持串行化的间接对象，或者引用含有循环结构的时候。</li>
</ol>
<p><strong>原型模式使用的场景：</strong></p>
<ol>
<li>资源优化场景：类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。</li>
<li>性能和安全要求的场景：通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。</li>
<li>一个对象多个修改者的场景：一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。</li>
</ol>
<p>在实际项目中，原型模式很少单独出现，一般是和工厂方法模式一起出现，通过clone的方法创建一个对象，然后由工厂方法提供给调用者。</p>
<h2 id="四、-NET-中原型模式的实现"><a href="#四、-NET-中原型模式的实现" class="headerlink" title="四、.NET 中原型模式的实现"></a>四、.NET 中原型模式的实现</h2><p>在.NET中，微软已经为我们提供了原型模式的接口实现，该接口就是ICloneable，其实这个接口就是抽象原型，提供克隆方法，相当于与上面代码中Prototype抽象类，其中的Clone()方法来实现原型模式，如果我们想我们自定义的类具有克隆的功能，首先定义类实现ICloneable接口的Clone方法。其实在.NET中实现了ICloneable接口的类有很多，如下图所示（图中只截取了部分，可以用ILSpy反编译工具进行查看）：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">System</span></span><br><span class="line">&#123;</span><br><span class="line">    [<span class="meta">ComVisible(true)</span>]</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">ICloneable</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">object</span> <span class="title">Clone</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在Net的FCL里面实现ICloneable接口的类如图，自己可以去查看每个类自己的实现，在此就不贴出来了。</p>
<p><img src="https://i.imgur.com/g4qdssG.png" alt=""></p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>到今天为止，所有的创建型设计模式就写完了。学习设计模式应该是有一个循序渐进的过程，当我们写代码的时候不要一上来就用什么设计模式，而是通过重构来使用设计模式。创建型的设计模式写完了，我们就总结一下。Singleton单件模式解决的是实体对象个数的问题。除了Singleton之外，其他创建型模式解决的都是new所带来的耦合关系。　Factory Method，Abstract Factory，Builder都需要一个额外的工厂类来负责实例化“易变对象”，而Prototype则是通过原型（一个特殊的工厂类）来克隆“易变对象”。（其实原型就是一个特殊的工厂类，它只是把工厂和实体对象耦合在一起了）。如果遇到“易变类”，起初的设计通常从Factory Method开始，当遇到更多的复杂变化时，再考虑重构为其他三种工厂模式（Abstract Factory，Builder，Prototype）。</p>
<p>一般来说，如果可以使用Factory Method，那么一定可以使用Prototype。但是Prototype的使用情况一般是在类比较容易克隆的条件之上，如果是每个类实现比较简单，都可以只用实现MemberwiseClone，没有引用类型的深拷贝，那么就更适合了。</p>

                                                            <p>本文链接：
                                                                <a href="https://netlover.cn/2018/08/18/csharp-prototype-pattern.html">
                                                                    https://netlover.cn/2018/08/18/csharp-prototype-pattern.html
                                                                </a>
                                                            </p>
                                                            
                                        </div>
                                        <div class="article-info article-info-index">
                                                
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Prototype-Pattern/">Prototype Pattern</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原型模式/">原型模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
	</div>


                                                    
                                                        
                                                                <div class="clearfix"></div>
                                            </div>
            </div>
            
                    
                            
                                        
</article>
  
    <article id="post-C#设计模式/C#设计模式(04) - 建造者模式(Builder Pattern)" class="article article-type-post" itemscope itemprop="blogPost">
    
        <div class="article-meta">
            <a href="/2018/08/18/csharp-builder-pattern.html" class="article-date">
  	<time datetime="2018-08-18T10:47:44.000Z" itemprop="datePublished">2018-08-18</time>
</a>

        </div>
        
            <div class="article-inner">
                
                    <input type="hidden" class="isFancy" />
                    
                        
                            <header class="article-header">
                                
  
    <h1 class="article-title" itemprop="name">
      <a href="/2018/08/18/csharp-builder-pattern.html">C#设计模式(04) - 建造者模式(Builder Pattern)</a>
    </h1>
  


                            </header>
                            <div class="article-info article-info-post">
                                    
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C-设计模式/">C#设计模式</a>
	</div>


                                    <div class="clearfix"></div>
                                </div>
                                    
                                        <div class="article-entry" itemprop="articleBody">
                                            
                                            
                                            
                                                        <h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>今天我们要讲讲Builder模式，也就是建造者模式，当然也有叫生成器模式的，英文名称是Builder Pattern。在现实生活中，我们经常会遇到一些构成比较复杂的物品，比如：电脑，它就是一个复杂的物品，它主要是由CPU、主板、硬盘、显卡、机箱等组装而成的。手机当然也是复杂物品，由主板，各种芯片，RAM 和ROM  摄像头之类的东西组成。但是无论是电脑还是手机，他们的组装过程是固定的，就拿手机来说，组装流水线是固定的，不变的，但是把不同的主板和其他组件组装在一起就会生产出不同型号的手机。那么在软件系统中是不是也会存在这样的对象呢？答案是肯定的。在软件系统中我们也会遇到类似的复杂对象，并且这个复杂对象的各个部分按照一定的算法组合在一起，此时该对象的创建工作就可以使用Builder模式了，下面我就来详细看看这个模式吧。</p>
<h2 id="二、建造者模式的详细介绍"><a href="#二、建造者模式的详细介绍" class="headerlink" title="二、建造者模式的详细介绍"></a>二、建造者模式的详细介绍</h2><h5 id="2-1、动机（Motivate）"><a href="#2-1、动机（Motivate）" class="headerlink" title="2.1、动机（Motivate）"></a>2.1、动机（Motivate）</h5><p>在软件系统中，有时候面临着“一个复杂对象”的创建工作，其通常由各个部分的子对象用一定的算法构成；由于需求的变化，这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起的算法却相对稳定。如何应对这种变化？如何提供一种“封装机制”来隔离出“复杂对象的各个部分”的变化，从而保持系统中的“稳定构建算法”不随着需求改变而改变？</p>
<h5 id="2-2、意图（Intent）"><a href="#2-2、意图（Intent）" class="headerlink" title="2.2、意图（Intent）"></a>2.2、意图（Intent）</h5><p>将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。                   ——《设计模式》GoF</p>
<h5 id="2-3、结构图（Structure）"><a href="#2-3、结构图（Structure）" class="headerlink" title="2.3、结构图（Structure）"></a>2.3、结构图（Structure）</h5><p><img src="https://i.imgur.com/sKhVRs1.jpg" alt=""></p>
<h5 id="2-4、模式的组成"><a href="#2-4、模式的组成" class="headerlink" title="2.4、模式的组成"></a>2.4、模式的组成</h5><p>1、抽象建造者角色（Builder）：为创建一个Product对象的各个部件指定抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此角色规定要实现复杂对象的哪些部分的创建，并不涉及具体的对象部件的创建。</p>
<p>2、具体建造者（ConcreteBuilder）</p>
<ul>
<li>实现Builder的接口以构造和装配该产品的各个部件。即实现抽象建造者角色Builder的方法。</li>
<li>定义并明确它所创建的表示，即针对不同的商业逻辑，具体化复杂对象的各部分的创建</li>
<li>提供一个检索产品的接口</li>
<li>构造一个使用Builder接口的对象即在指导者的调用下创建产品实例</li>
</ul>
<p>3、指导者（Director）：调用具体建造者角色以创建产品对象的各个部分。指导者并没有涉及具体产品类的信息，真正拥有具体产品的信息是具体建造者对象。它只负责保证对象各部分完整创建或按某种顺序创建。</p>
<p>4、产品角色（Product）：建造中的复杂对象。它要包含那些定义组件的类，包括将这些组件装配成产品的接口。</p>
<h5 id="2-5-建筑者模式的具体实现"><a href="#2-5-建筑者模式的具体实现" class="headerlink" title="2.5 建筑者模式的具体实现"></a>2.5 建筑者模式的具体实现</h5><p>现在人们生活水平都提高了，家家都有了家庭轿车，那今天我们就以汽车组装为例来说明Builder模式的实现。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span><br><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span><br><span class="line"><span class="keyword">using</span> System.Linq;</span><br><span class="line"><span class="keyword">using</span> System.Text;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 现在人们的生活水平都提高了，有钱了，我今天就以汽车组装为例子</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 每台汽车的组装过程都是一致的，所以我们使用同样的构建过程可以创建不同的表示(即可以组装成不同型号的汽车，不能像例子这样，一会别克，一会奥迪的)</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 组装汽车、电脑、手机、电视等等负责对象的这些场景都可以应用建造者模式来设计</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">namespace 设计模式之建造者模式</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 客户类</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Customer</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Director director = <span class="keyword">new</span> Director();</span><br><span class="line">            Builder buickCarBuilder = <span class="keyword">new</span> BuickBuilder();</span><br><span class="line">            Builder aoDiCarBuilder = <span class="keyword">new</span> AoDiBuilder();</span><br><span class="line">	</span><br><span class="line">            director.Construct(buickCarBuilder);</span><br><span class="line">	</span><br><span class="line">            <span class="comment">//组装完成，我来驾驶别克了</span></span><br><span class="line">            Car buickCar = buickCarBuilder.GetCar();</span><br><span class="line">            buickCar.Show();</span><br><span class="line">	</span><br><span class="line">            <span class="comment">// 我老婆就要奥迪了，她比较喜欢大品牌</span></span><br><span class="line">            director.Construct(aoDiCarBuilder);</span><br><span class="line">            Car aoDiCar = aoDiCarBuilder.GetCar();</span><br><span class="line">            aoDiCar.Show();</span><br><span class="line">	</span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 这个类型才是组装的，Construct方法里面的实现就是创建复杂对象固定算法的实现，该算法是固定的，或者说是相对稳定的</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 这个人当然就是老板了，也就是建造者模式中的指挥者</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Director</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 组装汽车</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Construct</span>(<span class="params">Builder builder</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            builder.BuildCarDoor();</span><br><span class="line">            builder.BuildCarWheel();</span><br><span class="line">            builder.BuildCarEngine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 汽车类</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 汽车部件集合</span></span><br><span class="line">        <span class="keyword">private</span> IList&lt;<span class="keyword">string</span>&gt; parts = <span class="keyword">new</span> List&lt;<span class="keyword">string</span>&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把单个部件添加到汽车部件集合中</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"><span class="keyword">string</span> part</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            parts.Add(part);</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"汽车开始在组装......."</span>);</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="keyword">string</span> part <span class="keyword">in</span> parts)</span><br><span class="line">            &#123;</span><br><span class="line">                Console.WriteLine(<span class="string">"组件"</span> + part + <span class="string">"已装好"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">	</span><br><span class="line">            Console.WriteLine(<span class="string">"汽车组装好了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 抽象建造者，它定义了要创建什么部件和最后创建的结果，但是不是组装的的类型，切记</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Builder</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建车门</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildCarDoor</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="comment">// 创建车轮</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildCarWheel</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="comment">//创建车引擎</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">BuildCarEngine</span>(<span class="params"></span>)</span>;</span><br><span class="line">        <span class="comment">// 当然还有部件，大灯、方向盘等，这里就省略了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获得组装好的汽车</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Car <span class="title">GetCar</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 具体创建者，具体的车型的创建者，例如：别克</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">BuickBuilder</span> : <span class="title">Builder</span></span><br><span class="line">    &#123;</span><br><span class="line">        Car buickCar = <span class="keyword">new</span> Car();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildCarDoor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            buickCar.Add(<span class="string">"Buick's Door"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildCarWheel</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            buickCar.Add(<span class="string">"Buick's Wheel"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildCarEngine</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            buickCar.Add(<span class="string">"Buick's Engine"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Car <span class="title">GetCar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> buickCar;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 具体创建者，具体的车型的创建者，例如：奥迪</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">AoDiBuilder</span> : <span class="title">Builder</span></span><br><span class="line">    &#123;</span><br><span class="line">        Car aoDiCar = <span class="keyword">new</span> Car();</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildCarDoor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            aoDiCar.Add(<span class="string">"Aodi's Door"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildCarWheel</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            aoDiCar.Add(<span class="string">"Aodi's Wheel"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">BuildCarEngine</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            aoDiCar.Add(<span class="string">"Aodi's Engine"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">	</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Car <span class="title">GetCar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> aoDiCar;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中都有详细的注释代码，这里就不过多解释。</p>
<h2 id="三、建造者模式的实现要点"><a href="#三、建造者模式的实现要点" class="headerlink" title="三、建造者模式的实现要点"></a>三、建造者模式的实现要点</h2><p>在建造者模式中，指挥者是直接与客户端打交道的，指挥者将客户端创建产品的请求划分为对各个部件的建造请求，再将这些请求委派到具体建造者角色，具体建造者角色是完成具体产品的构建工作的，却不为客户所知道。 建造者模式主要用于“分步骤来构建一个复杂的对象”，其中“分步骤”是一个固定的组合过程，而复杂对象的各个部分是经常变化的。 产品不需要抽象类，由于建造模式的创建出来的最终产品可能差异很大，所以不大可能提炼出一个抽象产品类。 在前面文章中介绍的抽象工厂模式解决了“系列产品”的需求变化，而建造者模式解决的是 “产品部分” 的需要变化。 由于建造者隐藏了具体产品的组装过程，所以要改变一个产品的内部表示，只需要再实现一个具体的建造者就可以了，从而能很好地应对产品组成组件的需求变化。</p>
<p><strong>建造者模式的优点：</strong></p>
<ol>
<li>使用建造者模式可以使客户端不必知道产品内部组成的细节。</li>
<li>具体的建造者类之间是相互独立的，容易扩展。</li>
<li>由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。</li>
</ol>
<p><strong>建造者模式的缺点：</strong></p>
<p>产生多余的Build对象以及Dirextor类。</p>
<p><strong>创建者模式的使用场景：</strong></p>
<ol>
<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li>
<li>相同的方法，不同的执行顺序，产生不同的事件结果时。</li>
<li>多个部件或零件,都可以装配到一个对象中，但是产生的运行结果又不相同时。</li>
<li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能。</li>
<li>创建一些复杂的对象时，这些对象的内部组成构件间的建造顺序是稳定的，但是对象的内部组成构件面临着复杂的变化。</li>
</ol>
<h2 id="四、-NET-中建造者模式的实现"><a href="#四、-NET-中建造者模式的实现" class="headerlink" title="四、.NET 中建造者模式的实现"></a>四、.NET 中建造者模式的实现</h2><p>在微软的类库里面大量使用了设计模式，如果要想学习设计模式，仔细看看微软的类库是很有帮助的。今天的设计模式在FCL里面也有实现，该类型的名字就是System.Text.StringBuilder(存在mscorlib.dll程序集中)，它就是一个建造者模式的实现，从名称也可以看出来。不过它的实现属于建造者模式的演化，此时的建造者模式没有指挥者角色和抽象建造者角色，StringBuilder类即扮演着具体建造者的角色，也同时扮演了指挥者和抽象建造者的角色，StringBuilder类扮演着建造string对象的具体建造者角色，其中的ToString()方法用来返回具体产品给客户端（相当于上面代码中GetProduct方法）。其中Append方法用来创建产品的组件(相当于上面代码中BuildPartA和BuildPartB方法)，因为string对象中每个组件都是字符，所以也就不需要指挥者的角色的代码（指的是Construct方法,用来调用创建每个组件的方法来完成整个产品的组装），因为string字符串对象中每个组件都是一样的,都是字符,所以Append方法也充当了指挥者Construct方法的作用。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>今天就到这里了，还需要重申的是，学习设计模式不能死学，就像StringBuilder一样，他和Gof23种设计模式中定义的情形有很大的不同，但是它也是Builder模式，因为它们要解决的问题和使用场景是吻合的。我们写代码的时候，不要太居于形式，要看使用的契机和模式是否吻合，根据具体的情况我们的模式也会发生变化。当我们看得越多，写的越多时候，你的变化就越自然了。</p>

                                                            <p>本文链接：
                                                                <a href="https://netlover.cn/2018/08/18/csharp-builder-pattern.html">
                                                                    https://netlover.cn/2018/08/18/csharp-builder-pattern.html
                                                                </a>
                                                            </p>
                                                            
                                        </div>
                                        <div class="article-info article-info-index">
                                                
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Builder-Pattern/">Builder Pattern</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/建造者模式/">建造者模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
	</div>


                                                    
                                                        
                                                                <div class="clearfix"></div>
                                            </div>
            </div>
            
                    
                            
                                        
</article>
  
    <article id="post-C#设计模式/C#设计模式(03) - 抽象工厂模式(Abstract Factory Pattern)" class="article article-type-post" itemscope itemprop="blogPost">
    
        <div class="article-meta">
            <a href="/2018/08/18/csharp-abstract-factory-pattern.html" class="article-date">
  	<time datetime="2018-08-18T09:47:44.000Z" itemprop="datePublished">2018-08-18</time>
</a>

        </div>
        
            <div class="article-inner">
                
                    <input type="hidden" class="isFancy" />
                    
                        
                            <header class="article-header">
                                
  
    <h1 class="article-title" itemprop="name">
      <a href="/2018/08/18/csharp-abstract-factory-pattern.html">C#设计模式(03) - 抽象工厂模式(Abstract Factory Pattern)</a>
    </h1>
  


                            </header>
                            <div class="article-info article-info-post">
                                    
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C-设计模式/">C#设计模式</a>
	</div>


                                    <div class="clearfix"></div>
                                </div>
                                    
                                        <div class="article-entry" itemprop="articleBody">
                                            
                                            
                                            
                                                        <h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>上一篇文章我们讲了【工厂方法】模式，它是为了解决【简单工厂】模式所面对的问题，它的问题就是：如果我们增加新的产品，工厂类的方法就要修改本身的代码，增加产品越多，其逻辑越复杂，同时这样的修改也是不符合【开放关闭原则OCP】，对修改代码关闭，对增加代码开放。为了解决【简单工厂】的问题，我们引出了【工厂方法】模式，通过子类化工厂类，解决了工厂类责任的划分，产品和相应的工厂一一对应，符合了OCP。如果我们要设计一套房子，当然我们知道房子是由房顶、地板、窗户、房门组成的，别的组件暂时省略，先设计一套古典风格的房子，再创建一套现代风格的房子，再创建一套欧式风格的房子，这么多套房子，我们该怎么办呢？今天我们要讲的【抽象工厂】模式可以很好的解决多套变化的问题。</p>
<h2 id="二、抽象工厂详细介绍"><a href="#二、抽象工厂详细介绍" class="headerlink" title="二、抽象工厂详细介绍"></a>二、抽象工厂详细介绍</h2><h5 id="2-1、动机-Motivate-："><a href="#2-1、动机-Motivate-：" class="headerlink" title="2.1、动机(Motivate)："></a>2.1、动机(Motivate)：</h5><p>在软件系统中，经常面临着”一系统相互依赖的对象”的创建工作：同时，由于需求的变化，往往存在更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象创建方法（new)，提供一种”封装机制”来避免客户程序和这种”多系列具体对象创建工作”的紧耦合？</p>
<h5 id="2-2、意图-Intent"><a href="#2-2、意图-Intent" class="headerlink" title="2.2、意图(Intent):"></a>2.2、意图(Intent):</h5><p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。                            ——《设计模式》GoF</p>
<h5 id="2-3、结构图（Structure）"><a href="#2-3、结构图（Structure）" class="headerlink" title="2.3、结构图（Structure）"></a>2.3、结构图（Structure）</h5><p><img src="https://i.imgur.com/gcPs3RB.png" alt=""></p>
<p>该图是抽象工厂的UML图，结合抽象工厂的意图、动机和图示来理解该模式，今天我们就以建设房子为例来说明抽象工厂的实现机理。</p>
<h5 id="2-4、模式的组成"><a href="#2-4、模式的组成" class="headerlink" title="2.4、模式的组成"></a>2.4、模式的组成</h5><p>可以看出，在抽象工厂模式的结构图有以下角色：</p>
<ol>
<li>抽象产品类角色（AbstractProduct）：为抽象工厂中相互依赖的每种产品定义抽象接口对象，也可以这样说，有几种产品，就要声明几个抽象角色，每一个抽象产品角色和一种具体的产品相匹配。</li>
<li>具体产品类（ConcreteProduct）：具体产品类实现了抽象产品类，是针对某个具体产品的实现的类型。</li>
<li>抽象工厂类角色（Abstract Factory）：定义了创建一组相互依赖的产品对象的接口操作，每种操作和每种产品一一对应。</li>
<li>具体工厂类角色（ConcreteFactory）：实现抽象类里面的所有抽象接口操作，可以创建某系列具体的产品，这些具体的产品是“抽象产品类角色”的子类。</li>
</ol>
<h5 id="2-5、抽象工厂的具体代码实现"><a href="#2-5、抽象工厂的具体代码实现" class="headerlink" title="2.5、抽象工厂的具体代码实现"></a>2.5、抽象工厂的具体代码实现</h5><p>随着我们年龄的增大，我们也到了结婚的年龄。结婚首要的问题就是房子的问题，假设我有一个很有钱的爸爸，哈哈，有钱可以解决很多问题。作为长子的我，希望能有一套欧式风格的房子，再加上田园风光，此生足矣。我弟弟就不一样了，他想要一套现代样式的房子，如果兄弟姊妹再多年一点，那就有更多的要求了。由于房子由房顶、地板、窗户和房门组成，其他组件暂时省略，有这么多套房子要建设，每套房子的房顶、地板、窗户和房门都是一个体系的，那就让我们看看如何使用【抽象工厂】模式来实现不同房屋的建造。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 下面以不同系列房屋的建造为例子演示抽象工厂模式</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 因为每个人的喜好不一样，我喜欢欧式的，我弟弟就喜欢现代的</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 客户端调用</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="comment">// 哥哥的欧式风格的房子</span></span><br><span class="line">		AbstractFactory europeanFactory= <span class="keyword">new</span> EuropeanFactory();</span><br><span class="line">		europeanFactory.CreateRoof().Create();</span><br><span class="line">		europeanFactory.CreateFloor().Create();</span><br><span class="line">		europeanFactory.CreateWindow().Create();</span><br><span class="line">		europeanFactory.CreateDoor().Create(); </span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">		<span class="comment">//弟弟的现代风格的房子</span></span><br><span class="line">		AbstractFactory modernizationFactory = <span class="keyword">new</span> ModernizationFactory();</span><br><span class="line">		modernizationFactory.CreateRoof().Create();</span><br><span class="line">		modernizationFactory.CreateFloor().Create();</span><br><span class="line">		modernizationFactory.CreateWindow().Create();</span><br><span class="line">		modernizationFactory.CreateDoor().Create();</span><br><span class="line">		Console.Read();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 抽象工厂类，提供创建不同类型房子的接口</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 抽象工厂提供创建一系列产品的接口，这里作为例子，只给出了房顶、地板、窗户和房门创建接口</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Roof <span class="title">CreateRoof</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Floor <span class="title">CreateFloor</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Window <span class="title">CreateWindow</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Door <span class="title">CreateDoor</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 欧式风格房子的工厂，负责创建欧式风格的房子</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EuropeanFactory</span> : <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 制作欧式房顶</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Roof <span class="title">CreateRoof</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> EuropeanRoof();</span><br><span class="line">	&#125;</span><br><span class="line">  </span><br><span class="line">	<span class="comment">// 制作欧式地板</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Floor <span class="title">CreateFloor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> EuropeanFloor();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 制作欧式窗户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Window <span class="title">CreateWindow</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> EuropeanWindow();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 制作欧式房门</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Door <span class="title">CreateDoor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> EuropeanDoor();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 现在风格房子的工厂，负责创建现代风格的房子</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ModernizationFactory</span> : <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 制作现代房顶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Roof <span class="title">CreateRoof</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ModernizationRoof();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 制作现代地板</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Floor <span class="title">CreateFloor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ModernizationFloor();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 制作现代窗户</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Window <span class="title">CreateWindow</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ModernizationWindow();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="comment">// 制作现代房门</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Door <span class="title">CreateDoor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> ModernizationDoor();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 房顶抽象类，子类的房顶必须继承该类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Roof</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> 创建房顶</span></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 地板抽象类，子类的地板必须继承该类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Floor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> 创建地板</span></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 窗户抽象类，子类的窗户必须继承该类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Window</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> 创建窗户</span></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 房门抽象类，子类的房门必须继承该类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Door</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> 创建房门</span></span><br><span class="line">	<span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 欧式地板类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EuropeanFloor</span> : <span class="title">Floor</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		Console.WriteLine(<span class="string">"创建欧式的地板"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 欧式的房顶</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EuropeanRoof</span> : <span class="title">Roof</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"创建欧式的房顶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>欧式的窗户</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EuropeanWindow</span> : <span class="title">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"创建欧式的窗户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 欧式的房门</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EuropeanDoor</span> : <span class="title">Door</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"创建欧式的房门"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 现代的房顶</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ModernizationRoof</span> : <span class="title">Roof</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">"创建现代的房顶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 现代的地板</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ModernizationFloor</span> : <span class="title">Floor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"创建现代的地板"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 现代的窗户</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ModernizationWindow</span> : <span class="title">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"创建现代的窗户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 现代的房门</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ModernizationDoor</span> : <span class="title">Door</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"创建现代的房门"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-6、-抽象工厂应对需求变更"><a href="#2-6、-抽象工厂应对需求变更" class="headerlink" title="2.6、 抽象工厂应对需求变更"></a>2.6、 抽象工厂应对需求变更</h5><p>让我们看看该模式如何应对需求的变化，假设我的表弟一看我们的房子很好，他也想要一套古典风格的房子（哈哈，这个家伙事挺多的，有好事总是落不下他）。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>先为表弟的房子来建立一个工厂类吧</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClassicalFactory</span> : <span class="title">AbstractFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建房顶</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Roof <span class="title">CreateRoof</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span>  ClassicalRoof();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建地板</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Floor <span class="title">CreateFloor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span>  ClassicalFloor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建窗户</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Window <span class="title">CreateWindow</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span>  ClassicalWindow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建房门</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Door <span class="title">CreateDoor</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span>  ClassicalDoor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span>古典的房顶</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title">ClassicalRoof</span> : <span class="title">Roof</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"创建古典的房顶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 古典的地板</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title">ClassicalFloor</span> : <span class="title">Floor</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"创建古典的地板"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 古典的窗户</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title">ClassicalWindow</span> : <span class="title">Window</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"创建古典的窗户"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 古典的房门</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span>  <span class="title">ClassicalDoor</span>: <span class="title">Door</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Create</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"创建古典的房门"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时，只需要添加五个类：一个是古典风格工厂类，负责创建古典风格的房子，另外几个类是具有古典风格的房顶、地板、窗户和房门的具体产品。从上面代码看出，抽象工厂对于系列产品的变化支持 “开放——封闭”原则（指的是要求系统对扩展开放，对修改封闭），扩展起来非常简便，但是，抽象工厂对于增加新产品这种情况就不支持”开放——封闭 “原则，因为要修改创建系列产品的抽象基类AbstractFactory，增加相应产品的创建方法，这也是抽象工厂的缺点所在。</p>
<h2 id="三、抽象工厂的实现要点"><a href="#三、抽象工厂的实现要点" class="headerlink" title="三、抽象工厂的实现要点"></a>三、抽象工厂的实现要点</h2><ol>
<li>如果没有应对“多系列对象创建”的需求变化，则没有必要使用AbstractFactory模式，这时候使用简单的静态工厂完全可以。</li>
<li>“系列对象”指的是这些对象之间有相互依赖、或作用的关系，例如游戏开发场景中“道路”与“房屋”的依赖，“道路”与“地道”的依赖。</li>
<li>AbstractFactory模式主要在于应对“新系列”的需求变动。其缺点在于难以应对“新对象”的需求变动。</li>
<li>AbstractFactory模式经常喝FactoryMethod模式共同组合来应对“对象创建”的需求变化。</li>
</ol>
<p><strong>抽象工厂模式的优点：</strong></p>
<p>【抽象工厂】模式将系列产品的创建工作延迟到具体工厂的子类中，我们声明工厂类变量的时候是使用的抽象类型，同理，我们使用产品类型也是抽象类型，这样做就尽可能的可以减少客户端代码与具体产品类之间的依赖，从而降低了系统的耦合度。耦合度降低了，对于后期的维护和扩展就更有利，这也就是【抽象工厂】模式的优点所在。可能有人会说在Main方法里面（这里的代码就是客户端的使用方）还是会使用具体的工厂类，对的。这个其实我们通过Net的配置，把这部分移出去，最后把依赖关系放到配置文件中。如果有新的需求我们只需要修改配置文件，根本就不需要修改代码了，让客户代码更稳定。依赖关系肯定会存在，我们要做的就是降低依赖，想完全去除很难，也不现实。</p>
<p><strong>抽象工厂模式的缺点：</strong></p>
<p>有优点肯定就有缺点，因为每种模式都有他的使用范围，或者说要解决的问题，不能解决的问题就是缺点了，其实也不能叫缺点了。【抽象工厂】模式很难支持增加新产品的变化，这是因为抽象工厂接口中已经确定了可以被创建的产品集合，如果需要添加新产品，此时就必须去修改抽象工厂的接口，这样就涉及到抽象工厂类的以及所有子类的改变，这样也就违背了“开发——封闭”原则。</p>
<p><strong>抽象工厂模式的使用场景：</strong></p>
<p>如果系统需要多套的代码解决方案，并且每套的代码方案中又有很多相互关联的产品类型，并且在系统中我们可以相互替换的使用一套产品的时候可以使用该模式，客户端不需要依赖具体实现。</p>
<h2 id="四、-NET中抽象工厂模式实现"><a href="#四、-NET中抽象工厂模式实现" class="headerlink" title="四、.NET中抽象工厂模式实现"></a>四、.NET中抽象工厂模式实现</h2><p>微软的类库发展了这么多年，设计模式在里面有大量的应用，【抽象工厂】模式在.NET类库中也存在着大量的使用，比如和操作数据库有关的类型，这个类就是System.Data.Common.DbProviderFactory，这个类位于System.Data.dll程序集中。该类扮演抽象工厂模式中抽象工厂的角色，我们可以用ILSpy反编译工具查看该类的实现：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> 扮演抽象工厂的角色</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 创建连接数据库时所需要的对象集合，</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 这个对象集合包括有 DbConnection对象（这个是抽象产品类,如绝味例子中的YaBo类）、DbCommand类、DbDataAdapter类，针对不同的具体工厂都需要实现该抽象类中方法，</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">DbProviderFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">virtual</span> <span class="keyword">bool</span> CanCreateDataSourceEnumerator</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> DbCommand <span class="title">CreateCommand</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> DbCommandBuilder <span class="title">CreateCommandBuilder</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> DbConnection <span class="title">CreateConnection</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> DbConnectionStringBuilder <span class="title">CreateConnectionStringBuilder</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> DbDataAdapter <span class="title">CreateDataAdapter</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> DbParameter <span class="title">CreateParameter</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> CodeAccessPermission <span class="title">CreatePermission</span>(<span class="params">PermissionState state</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">virtual</span> DbDataSourceEnumerator <span class="title">CreateDataSourceEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DbProviderFactory类是一个抽象工厂类，该类提供了创建数据库连接时所需要的对象集合的接口，实际创建的工作在其子类工厂中进行，微软使用的是SQL Server数据库，因此提供了连接SQL Server数据的具体工厂实现，具体代码可以用反编译工具查看，具体代码如下：</p>
<p>SqlClientFactory扮演着具体工厂的角色，用来创建连接SQL Server数据所需要的对象</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">public sealed class SqlClientFactory : DbProviderFactory, IServiceProvider</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> SqlClientFactory Instance = <span class="keyword">new</span> SqlClientFactory();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> CanCreateDataSourceEnumerator</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">get</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SqlClientFactory</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DbCommand <span class="title">CreateCommand</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlCommand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DbCommandBuilder <span class="title">CreateCommandBuilder</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlCommandBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DbConnection <span class="title">CreateConnection</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DbConnectionStringBuilder <span class="title">CreateConnectionStringBuilder</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlConnectionStringBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DbDataAdapter <span class="title">CreateDataAdapter</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlDataAdapter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DbParameter <span class="title">CreateParameter</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlParameter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> CodeAccessPermission <span class="title">CreatePermission</span>(<span class="params">PermissionState state</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SqlClientPermission(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DbDataSourceEnumerator <span class="title">CreateDataSourceEnumerator</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SqlDataSourceEnumerator.Instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">object</span> IServiceProvider.GetService(Type serviceType)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">object</span> result = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (serviceType == GreenMethods.SystemDataCommonDbProviderServices_Type)</span><br><span class="line">        &#123;</span><br><span class="line">            result = GreenMethods.SystemDataSqlClientSqlProviderServices_Instance();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OdbcFactory也是具体工厂类</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">OdbcFactory</span> : <span class="title">DbProviderFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> OdbcFactory Instance = <span class="keyword">new</span> OdbcFactory();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">OdbcFactory</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DbCommand <span class="title">CreateCommand</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OdbcCommand();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DbCommandBuilder <span class="title">CreateCommandBuilder</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OdbcCommandBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DbConnection <span class="title">CreateConnection</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OdbcConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DbConnectionStringBuilder <span class="title">CreateConnectionStringBuilder</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OdbcConnectionStringBuilder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DbDataAdapter <span class="title">CreateDataAdapter</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OdbcDataAdapter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> DbParameter <span class="title">CreateParameter</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OdbcParameter();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> CodeAccessPermission <span class="title">CreatePermission</span>(<span class="params">PermissionState state</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> OdbcPermission(state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当然，我们也有OleDbFactory 类型，都是负责具体的数据库操作。DbProviderFactory就是【抽象工厂】模式UML里面AbstractFactory类型。其他具体的工厂类型继承DbProviderFactory类型，这个结构很简单，我就不画图了。</p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>终于写完了，写了3个小时，学习设计模式不能死学，要把握核心点和使用场景。关键点第一是，面向对象设计模式的基本原则，有了原则，考虑问题就不会跑偏，然后再仔细把握每种模式的使用场景和要解决的问题，多写写代码，多看看Net的类库，它是最好的教材。</p>

                                                            <p>本文链接：
                                                                <a href="https://netlover.cn/2018/08/18/csharp-abstract-factory-pattern.html">
                                                                    https://netlover.cn/2018/08/18/csharp-abstract-factory-pattern.html
                                                                </a>
                                                            </p>
                                                            
                                        </div>
                                        <div class="article-info article-info-index">
                                                
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Abstract-Factory-Pattern/">Abstract Factory Pattern</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/抽象工厂模式/">抽象工厂模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
	</div>


                                                    
                                                        
                                                                <div class="clearfix"></div>
                                            </div>
            </div>
            
                    
                            
                                        
</article>
  
    <article id="post-C#设计模式/C#设计模式(02) - 工厂方法模式(Factory Method Pattern)" class="article article-type-post" itemscope itemprop="blogPost">
    
        <div class="article-meta">
            <a href="/2018/08/18/csharp-factory-method-pattern.html" class="article-date">
  	<time datetime="2018-08-18T08:54:44.000Z" itemprop="datePublished">2018-08-18</time>
</a>

        </div>
        
            <div class="article-inner">
                
                    <input type="hidden" class="isFancy" />
                    
                        
                            <header class="article-header">
                                
  
    <h1 class="article-title" itemprop="name">
      <a href="/2018/08/18/csharp-factory-method-pattern.html">C#设计模式(02) - 工厂方法模式(Factory Method Pattern)</a>
    </h1>
  


                            </header>
                            <div class="article-info article-info-post">
                                    
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C-设计模式/">C#设计模式</a>
	</div>


                                    <div class="clearfix"></div>
                                </div>
                                    
                                        <div class="article-entry" itemprop="articleBody">
                                            
                                            
                                            
                                                        <h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>在上一篇文章中我们讲解了过渡的一种模式叫做【简单工厂】，也有叫【静态工厂】的，通过对简单工厂模式得了解，我们也发现了它的缺点，就是随着需求的变化我们要不停地修改工厂里面的方法的代码，需求变化越多，里面的If–Else–也越多，这样就会造成简单工厂的实现逻辑过于复杂。设计模式是遵循一定原则而得来的，比如，我们要怎么增加代码，怎么修改代码，不是想怎么来就怎么来的，其中一个原则就是OCP原则，中文是【开放关闭原则】，对增加代码开发，对修改代码关闭，所以我们就不能总是这样修改简单工厂里面的方法。本章介绍的工厂方法模式可以解决简单工厂模式中存在的这个问题，下面就具体看看工厂方法模式是如何解决该问题的。</p>
<h2 id="二、工厂方法模式的胡介绍"><a href="#二、工厂方法模式的胡介绍" class="headerlink" title="二、工厂方法模式的胡介绍"></a>二、工厂方法模式的胡介绍</h2><h5 id="2-1、动机（Motivate）"><a href="#2-1、动机（Motivate）" class="headerlink" title="2.1、动机（Motivate）"></a>2.1、动机（Motivate）</h5><p>在软件系统的构建过程中，经常面临着“某个对象”的创建工作：由于需求的变化，这个对象（的具体实现）经常面临着剧烈的变化，但是它却拥有比较稳定的接口。</p>
<p>如何应对这种变化？如何提供一种“封装机制”来隔离出“这个易变对象”的变化，从而保持系统中“其他依赖对象的对象”不随着需求改变而改变？</p>
<h5 id="2-2、意图（Intent）"><a href="#2-2、意图（Intent）" class="headerlink" title="2.2、意图（Intent）"></a>2.2、意图（Intent）</h5><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使得一个类的实例化延迟到子类。                                        –《设计模式》GoF</p>
<h5 id="2-3、结构图（Structure）"><a href="#2-3、结构图（Structure）" class="headerlink" title="2.3、结构图（Structure）"></a>2.3、结构图（Structure）</h5><p><img src="https://i.imgur.com/OydX8mx.png" alt=""></p>
<h5 id="2-4、模式的组成"><a href="#2-4、模式的组成" class="headerlink" title="2.4、模式的组成"></a>2.4、模式的组成</h5><p>可以看出，在工厂方法模式的结构图有以下角色：</p>
<ol>
<li>抽象工厂角色（Creator）: 充当抽象工厂角色，定义工厂类所具有的基本的操作，任何具体工厂都必须继承该抽象类。</li>
<li>具体工厂角色（ConcreteCreator）：充当具体工厂角色，该类必须继承抽象工厂角色，实现抽象工厂定义的方法，用来创建具体产品。</li>
<li>抽象产品角色（Product）：充当抽象产品角色，定义了产品类型所有具有的基本操作，具体产品必须继承该抽象类。</li>
<li>具体产品角色（ConcreteProduct）：充当具体产品角色，实现抽象产品类对定义的抽象方法，由具体工厂类创建，它们之间有一一对应的关系。</li>
</ol>
<h5 id="2-5、工厂方法模式的代码实现"><a href="#2-5、工厂方法模式的代码实现" class="headerlink" title="2.5、工厂方法模式的代码实现"></a>2.5、工厂方法模式的代码实现</h5><p>【简单工厂模式】的问题是：如果有新的需求就需要修改工厂类里面创建产品对象实例的那个方法的实现代码，在面向对象设计一个原则就是哪里有变化，我就封装哪里。还有另外两个大的原则，其一是：面向抽象编程，细节和高层实现都要依赖抽象，第二个原则是：多组合，少继承。这三个原则是最根本的原则，学习设计模式必须以这三个原则为基点，否则都是枉然。根据这三大原则又衍生出来6个具体的原则，分别是【单一职责原则】，【里氏替换原则】，【依赖倒置原则】，【接口隔离原则】、【迪米特法则】和【开闭原则】，既然工厂类有变化，我们就封装它，面向抽象编程，我们先抽象出一个工厂基类，然后，每个需求就实现一个具体的工厂类，这样我们就符合了【开闭原则OCP】，让一个工厂生产一款产品，并一一对应。我们把具体产品的创建推迟到子类中，此时工厂类（这类是基类了）不再负责所有产品的创建，而只是给出具体工厂必须实现的接口，这样工厂方法模式就可以允许系统不修改工厂类逻辑的情况下来添加新产品，这样也就克服了简单工厂模式中缺点。下面就是工厂方法模式的实现代码：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">namespace 设计模式之工厂方法模式</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 汽车抽象类</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Car</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 开始行驶</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 红旗汽车</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HongQiCar</span> : <span class="title">Car</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"红旗汽车开始行驶了！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 奥迪汽车</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AoDiCar</span> : <span class="title">Car</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            Console.WriteLine(<span class="string">"奥迪汽车开始行驶了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 抽象工厂类</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Factory</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 工厂方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Car <span class="title">CreateCar</span>(<span class="params"></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 红旗汽车工厂类</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">HongQiCarFactory</span>:<span class="title">Factory</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 负责生产红旗汽车</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Car <span class="title">CreateCar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> HongQiCar();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 奥迪汽车工厂类</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AoDiCarFactory</span>:<span class="title">Factory</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> 负责创建奥迪汽车</span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">        <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Car <span class="title">CreateCar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> AoDiCar();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 客户端调用</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 初始化创建汽车的两个工厂</span></span><br><span class="line">            Factory hongQiCarFactory = <span class="keyword">new</span> HongQiCarFactory();</span><br><span class="line">            Factory aoDiCarFactory = <span class="keyword">new</span> AoDiCarFactory();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 生产一辆红旗汽车</span></span><br><span class="line">            Car hongQi = hongQiCarFactory.CreateCar();</span><br><span class="line">            hongQi.Go();</span><br><span class="line">	</span><br><span class="line">            <span class="comment">//生产一辆奥迪汽车</span></span><br><span class="line">            Car aoDi = aoDiCarFactory.CreateCar();</span><br><span class="line">            aoDi.Go();</span><br><span class="line">	</span><br><span class="line">            Console.Read();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在【工厂方法模式】中，我们同样也把汽车的类抽象出来一个抽象的基类，这里正好符合了【面向抽象编程】，客户端在使用的时候不会依赖具体的什么汽车。使用工厂方法实现的系统，如果系统需要添加新产品时，我们可以利用多态性来完成系统的扩展，对于抽象工厂类和具体工厂中的代码都不需要做任何改动。例如，我们想增加一辆奔驰车，我们只需从Car抽象类下继承一个BenChiCar类，同时在从Factory抽象基类下继承一个“奔驰”的工厂类BenChinaCarFactory就可以了，这样扩展符合OCP的原则。具体代码为：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 奔驰车</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BenChiCar</span> : <span class="title">Car</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 重写抽象类中的方法</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">Go</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Console.WriteLine(<span class="string">"奔驰车开始行驶了！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 奔驰车的工厂类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BenChiCarFactory</span> : <span class="title">Factory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 负责生产奔驰车</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Car <span class="title">CreateCar</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BenChiCar();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 客户端调用</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title">Client</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果客户又生产一辆奔驰车</span></span><br><span class="line">        <span class="comment">// 再另外初始化一个奔驰车的工厂</span></span><br><span class="line">        Factory benChiCarFactory = <span class="keyword">new</span> BenChiCarFactory();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 利用奔驰车的工厂生产奔驰车</span></span><br><span class="line">        Car benChi = benChiCarFactory.CreateCar();</span><br><span class="line">        benChi.Go();</span><br><span class="line"></span><br><span class="line">        Console.Read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三、Factory Method模式的几个要点</p>
<p>Factory Method模式主要用于隔离类对象的使用者和具体类型之间的耦合关系。面对一个经常变化的具体类型，紧耦合关系会导致软件的脆弱。</p>
<p>Factory Method模式通过面向对象的手法，将所要创建的具体对象工作延迟到子类，从而实现一种扩展（而非更改）的策略，较好地解决了这种紧耦合关系。</p>
<ul>
<li>Factory Method模式解决“单个对象”的需求变化；</li>
<li>AbstractFactory模式解决“系列对象”的需求变化；</li>
<li>Builder模式解决“对象部分”的需求变化；</li>
</ul>
<p><strong>工厂方法模式的优点：</strong></p>
<ol>
<li>在工厂方法中，用户只需要知道所要产品的具体工厂，无须关系具体的创建过程，甚至不需要具体产品类的类名。</li>
<li>在系统增加新的产品时，我们只需要添加一个具体产品类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则”。</li>
</ol>
<p><strong>工厂方法模式的缺点：</strong></p>
<p>每次增加一个产品时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事。</p>
<p><strong>工厂方法模式使用的场景：</strong></p>
<ol>
<li>一个类不知道它所需要的对象的类。在工厂方法模式中，我们不需要具体产品的类名，我们只需要知道创建它的具体工厂即可。</li>
<li>一个类通过其子类来指定创建那个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
<li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</li>
</ol>
<p>四、.NET中实现了工厂方法的类</p>
<p>.NET 类库中也有很多实现了工厂方法的类，例如Asp.net中，处理程序对象是具体用来处理请求，当我们请求一个<em>.aspx的文件时，此时会映射到System.Web.UI.PageHandlerFactory类上进行处理，而对</em>.ashx的请求将映射到System.Web.UI.SimpleHandlerFactory类中（这两个类都是继承于IHttpHandlerFactory接口的），关于这点说明我们可以在“C:\Windows\Microsoft.NET\Framework\v4.0.30319\Config\Web.Config”文件中找到相关定义，具体定义如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">add</span> <span class="attr">path</span>=<span class="string">"*.axd"</span> <span class="attr">verb</span>=<span class="string">"*"</span> <span class="attr">type</span>=<span class="string">"System.Web.HttpNotFoundHandler"</span> <span class="attr">validate</span>=<span class="string">"True"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">add</span> <span class="attr">path</span>=<span class="string">"*.aspx"</span> <span class="attr">verb</span>=<span class="string">"*"</span> <span class="attr">type</span>=<span class="string">"System.Web.UI.PageHandlerFactory"</span> <span class="attr">validate</span>=<span class="string">"True"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">add</span> <span class="attr">path</span>=<span class="string">"*.ashx"</span> <span class="attr">verb</span>=<span class="string">"*"</span> <span class="attr">type</span>=<span class="string">"System.Web.UI.SimpleHandlerFactory"</span> <span class="attr">validate</span>=<span class="string">"True"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置文件截图了一部分，有时间大家可以自己去研究一下。<br>下面我们就具体看下工厂方法模式在Asp.net中是如何实现的，如果对一个Index.aspx页面发出请求时，将会调用PageHandlerFactory中GetHandler方法来创建一个Index.aspx对象，它们之间的类图关系如下：</p>
<p><img src="https://i.imgur.com/9oQmDee.jpg" alt=""></p>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>每种模式都有自己的使用场合，切记，如果使用错误，还不如不用。工厂方法模式通过面向对象编程中的多态性来将对象的创建延迟到具体工厂中，从而解决了简单工厂模式中存在的问题，也很好地符合了开放封闭原则（即对扩展开发，对修改封闭）。</p>
<blockquote>
<p>学习设计模式我们一定要谨记设计模式的几大原则，否则是徒劳无功的。就像学务工一样，我们要记心法。6大原则就像孤独求败的独孤九剑的剑诀，学会了，变化无穷。</p>
</blockquote>

                                                            <p>本文链接：
                                                                <a href="https://netlover.cn/2018/08/18/csharp-factory-method-pattern.html">
                                                                    https://netlover.cn/2018/08/18/csharp-factory-method-pattern.html
                                                                </a>
                                                            </p>
                                                            
                                        </div>
                                        <div class="article-info article-info-index">
                                                
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Factory-Method-Pattern/">Factory Method Pattern</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/工厂方法模式/">工厂方法模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
	</div>


                                                    
                                                        
                                                                <div class="clearfix"></div>
                                            </div>
            </div>
            
                    
                            
                                        
</article>
  
    <article id="post-C#设计模式/C#设计模式(01) - 单例模式(Singleton Pattern)" class="article article-type-post" itemscope itemprop="blogPost">
    
        <div class="article-meta">
            <a href="/2018/08/18/csharp-singleton-pattern.html" class="article-date">
  	<time datetime="2018-08-18T08:47:44.000Z" itemprop="datePublished">2018-08-18</time>
</a>

        </div>
        
            <div class="article-inner">
                
                    <input type="hidden" class="isFancy" />
                    
                        
                            <header class="article-header">
                                
  
    <h1 class="article-title" itemprop="name">
      <a href="/2018/08/18/csharp-singleton-pattern.html">C#设计模式(01) - 单例模式(Singleton Pattern)</a>
    </h1>
  


                            </header>
                            <div class="article-info article-info-post">
                                    
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/C-设计模式/">C#设计模式</a>
	</div>


                                    <div class="clearfix"></div>
                                </div>
                                    
                                        <div class="article-entry" itemprop="articleBody">
                                            
                                            
                                            
                                                        <h2 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h2><p>看了李建忠老师的讲的设计模式已经有一段时间了（这段时间大概有一年多了），自己还没有写过自己的、有关设计模式的文章。这次想写一些关于设计模式的文章，用自己的理解和代码来写，算是复习一遍。写作的过程中也会多看看其他大牛的文章，争取让自己的理解正确，否则把大家带跑偏了，就是我的过错了。今天就开始我们第一个设计模式，该模式是：【单例模式】，英文名称：Singleton Pattern，这个模式很简单，一个类型只需要一个实例，他是创建型的设计模式。为什么叫“创建型”设计模式呢，因为他们有分类。当然了分类的方式不一样，分类的结果也就不一样。</p>
<h5 id="从目的来看："><a href="#从目的来看：" class="headerlink" title="从目的来看："></a>从目的来看：</h5><ul>
<li>创建型（Creational）模式：负责对象创建</li>
<li>结构型（Structural）模式：处理类与对象间的组合</li>
<li>行为型（Behavioral）模式：类与对象交互中的职责分配</li>
</ul>
<h5 id="从范围来看："><a href="#从范围来看：" class="headerlink" title="从范围来看："></a>从范围来看：</h5><ul>
<li><p>类模式处理类与子类的静态关系</p>
</li>
<li><p>对象模式处理对象间的动态关系</p>
</li>
</ul>
<p>以上就是分类的方式，我们按大多数的分类，采用“从目的来看”的分类来对设计模式进行分类，我们就开始今天的学习吧。</p>
<h2 id="二、单例模式的介绍"><a href="#二、单例模式的介绍" class="headerlink" title="二、单例模式的介绍"></a>二、单例模式的介绍</h2><h5 id="2-1、动机（Motivate）"><a href="#2-1、动机（Motivate）" class="headerlink" title="2.1、动机（Motivate）"></a>2.1、动机（Motivate）</h5><p>在软件系统中，经常有这样一些特殊的类，必须保证它们在系统中只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率。</p>
<p>如何绕过常规的构造器，提供一种机制来保证一个类只有一个实例？</p>
<p><strong>这应该是类设计者的责任，而不是使用者的责任</strong></p>
<h5 id="2-2、意图（Intent）"><a href="#2-2、意图（Intent）" class="headerlink" title="2.2、意图（Intent）"></a>2.2、意图（Intent）</h5><p>保证一个类仅有一个实例，并提供一个该实例的全局访问点。–《设计模式GoF》</p>
<h5 id="2-3、结构图（Structure）"><a href="#2-3、结构图（Structure）" class="headerlink" title="2.3、结构图（Structure）"></a>2.3、结构图（Structure）</h5><p><img src="https://i.imgur.com/WLCxSzO.png" alt=""></p>
<h5 id="2-4、模式的组成"><a href="#2-4、模式的组成" class="headerlink" title="2.4、模式的组成"></a>2.4、模式的组成</h5><p>单件实例（Singleton）：这个模式里面只有一个类型，就是Singleton类型，并且这个类只有一个实例，可以通过Instance()方法获取该类型的实例。</p>
<h5 id="2-5、单件模式的代码实现"><a href="#2-5、单件模式的代码实现" class="headerlink" title="2.5、单件模式的代码实现"></a>2.5、单件模式的代码实现</h5><p>既然是单实例，肯定会涉及到多线程的问题，我们就一步一步的来写代码，<strong>我们先看看单线程Singleton模式的实现</strong>，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 单例模式的实现</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个静态变量来保存类的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 定义私有构造函数，使外界不能创建该类实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	 </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 如果类的实例不存在则创建，否则直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>私有的实例构造器是屏蔽外界的调用，上面的单例模式的实现在单线程下确实是完美的，也很好的满足了我们单线程环境的需求。</p>
<p><strong>单线程单例模式的几个要点：</strong></p>
<ol>
<li>Singleton模式中的实例构造器可以设置为protected以允许子类派生。</li>
<li>Singleton模式一般不要支持ICloneable接口，因为这可能会导致多个对象实例，与Singleton模式的初衷违背。</li>
<li>Singleton模式一般不要支持序列化，因为这也有可能导致多个对象实例，同样与Singleton模式的初衷违背。</li>
<li>Singletom模式只考虑到了对象创建的工作，没有考虑对象销毁的工作。为什么这样做呢，因为Net平台是支持垃圾回收的，所以我们一般没有必要对其进行销毁处理。</li>
<li>不能应对多线程环境：在多线程环境下，使用Singleton模式仍然有可能得到Singleton类的多个实例对象</li>
</ol>
<p>如果放在多线程环境下，问题就出来了。因为在两个线程同时运行GetInstance方法时，此时两个线程判断(uniqueInstance ==null)这个条件时都返回真，此时两个线程就都会创建Singleton的实例，这样就违背了我们单例模式初衷了。要想解决这个问题，只要让GetInstance方法在同一时间只运行一个线程运行就好了，让我们看看<strong>多线程Singleton模式</strong>的实现，代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 单例模式的实现</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个静态变量来保存类的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton uniqueInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个标识确保线程同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">object</span> locker = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 定义私有构造函数，使外界不能创建该类实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 当第一个线程运行到这里时，此时会对locker对象 "加锁"，</span></span><br><span class="line">        <span class="comment">// 当第二个线程运行该方法时，首先检测到locker对象为"加锁"状态，该线程就会挂起等待第一个线程解锁</span></span><br><span class="line">        <span class="comment">// lock语句运行完之后（即线程运行完之后）会对该对象"解锁"</span></span><br><span class="line">        <span class="keyword">lock</span> (locker)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 如果类的实例不存在则创建，否则直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这种解决方案确实可以解决多线程的问题，但是上面代码对于每个线程都会对线程辅助对象locker加锁之后再判断实例是否存在，对于这个操作完全没有必要的，因为当第一个线程创建了该类的实例之后，后面的线程此时只需要直接判断（uniqueInstance==null）为假，此时完全没必要对线程辅助对象加锁之后再去判断，所以上面的实现方式增加了额外的开销，损失了性能，为了改进上面实现方式的缺陷，我们只需要在lock语句前面加一句（uniqueInstance==null）的判断就可以避免锁所增加的额外开销，这种实现方式我们就叫它 “<strong>双重锁定（Double Check）</strong>”，下面具体看看实现代码的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 单例模式的实现</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 定义一个静态变量来保存类的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton uniqueInstance;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 定义一个标识确保线程同步</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> <span class="keyword">object</span> locker = <span class="keyword">new</span> <span class="keyword">object</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 定义私有构造函数，使外界不能创建该类实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> 定义公有方法提供一个全局访问点,同时你也可以定义公有属性来提供全局访问点</span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line">    <span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">GetInstance</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 当第一个线程运行到这里时，此时会对locker对象 "加锁"，</span></span><br><span class="line">        <span class="comment">// 当第二个线程运行该方法时，首先检测到locker对象为"加锁"状态，该线程就会挂起等待第一个线程解锁</span></span><br><span class="line">        <span class="comment">// lock语句运行完之后（即线程运行完之后）会对该对象"解锁"</span></span><br><span class="line">        <span class="comment">// 双重锁定只需要一句判断就可以了</span></span><br><span class="line">        <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">lock</span> (locker)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 如果类的实例不存在则创建，否则直接返回</span></span><br><span class="line">                <span class="keyword">if</span> (uniqueInstance == <span class="literal">null</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>volatile修饰：</strong>编译器在编译代码的时候会对代码的顺序进行微调，用volatile修饰保证了严格意义的顺序。一个定义为volatile的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假设这个变量的值了。精确地说就是，优化器在用到这个变量时必须每次都小心地重新读取这个变量的值，而不是使用保存在寄存器里的备份。</p>
<h2 id="三、C-中实现了单例模式的类"><a href="#三、C-中实现了单例模式的类" class="headerlink" title="三、C#中实现了单例模式的类"></a>三、C#中实现了单例模式的类</h2><p>现在我们看看，如何使用C#语言的特性来实现单例的Singleton模式。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Singleton模式的实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">	</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">以上是内联初始化（生成的同时进行初始化）的单例模式，它等同于：</span><br><span class="line"></span><br><span class="line">```csharp</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">readonly</span> Singleton instance;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//静态构造函数，CLR只执行一次</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">Singleton</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       instance=<span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">   <span class="comment">//私有构造函数，防止外界调用</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内联初始化其实是把静态的字段放到静态构造器去初始化。只要想访问静态字段，必定已经在之前执行了静态构造器。这样也能够精确地保证使用的时候一定能拿到实例，如果不使用也不会实例化对象，也就是延时加载的功能。他同样能够支持多线程环境，因为只可能有一个线程执行静态构造器，不可能有多个线程去执行静态构造器，感觉就是程序已经自动为我们加锁了。</p>
<p>它的一点弊端就是它不支持参数化的实例化方法。在.NET里静态构造器只能声明一个，而且必须是无参数的，私有的。因此这种方式只适用于无参数的构造器。</p>
<p>需要说明的是：HttpContext.Current就是一个单例，他们是通过Singleton的扩展方式实现的，他们的单例也并不是覆盖所有领域，只是针对某些局部领域中，是单例的，不同的领域中还是会有不同的实例。</p>
<h2 id="四、Singleton模式的扩展"><a href="#四、Singleton模式的扩展" class="headerlink" title="四、Singleton模式的扩展"></a>四、Singleton模式的扩展</h2><ol>
<li>将一个实例扩展到n个实例，例如对象池的实现。（n不是指无限个实例，而是固定的某个数）</li>
<li>将new构造器的调用转移到其他类中，例如多个类协同工作环境中，某个局部环境只需要拥有某个类的一个实例。</li>
<li>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的实例构造器的任意调用”。</li>
</ol>
<h2 id="五、单例模式的实现要点"><a href="#五、单例模式的实现要点" class="headerlink" title="五、单例模式的实现要点"></a>五、单例模式的实现要点</h2><ol>
<li>Singleton模式是限制而不是改进类的创建。</li>
<li>Singleton类中的实例构造器可以设置为Protected以允许子类派生。</li>
<li>Singleton模式一般不要支持Icloneable接口，因为这可能导致多个对象实例，与Singleton模式的初衷违背。</li>
<li>Singleton模式一般不要支持序列化，这也有可能导致多个对象实例，这也与Singleton模式的初衷违背。</li>
<li>Singleton只考虑了对象创建的管理，没有考虑到销毁的管理，就支持垃圾回收的平台和对象的开销来讲，我们一般没必要对其销毁进行特殊的管理。</li>
<li>理解和扩展Singleton模式的核心是“如何控制用户使用new对一个类的构造器的任意调用”。</li>
<li>可以很简单的修改一个Singleton，使它有少数几个实例，这样做是允许的而且是有意义的。</li>
</ol>
<h3 id="单例模式的优点："><a href="#单例模式的优点：" class="headerlink" title="单例模式的优点："></a>单例模式的优点：</h3><ol>
<li>实例控制：Singleton 会阻止其他对象实例化其自己的 Singleton 对象的副本，从而确保所有对象都访问唯一实例</li>
<li>灵活性：因为类控制了实例化过程，所以类可以更加灵活修改实例化过程</li>
</ol>
<h3 id="单例模式的缺点："><a href="#单例模式的缺点：" class="headerlink" title="单例模式的缺点："></a>单例模式的缺点：</h3><ol>
<li>开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题。</li>
<li>可能的开发混淆：使用 singleton 对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用 new 关键字实例化对象。因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。</li>
<li>对象的生存期：Singleton 不能解决删除单个对象的问题。因为它包含对该静态的私有字段的引用，静态字段是不能被CLR回收内存的，该实例会和应用程序生命周期一样长，一直存在。</li>
</ol>
<h3 id="单例模式的使用场合："><a href="#单例模式的使用场合：" class="headerlink" title="单例模式的使用场合："></a>单例模式的使用场合：</h3><ol>
<li>当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。</li>
<li>当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。</li>
</ol>
<h2 id="六、总结"><a href="#六、总结" class="headerlink" title="六、总结"></a>六、总结</h2><p>到这里，单例模式就介绍完了，这个模式很简单，理解起来也不是很难，只要把握住代码的实现技巧，一般问题都不大，但是要找好使用的时机，如果使用错误，一些逻辑错误比较难排查。</p>

                                                            <p>本文链接：
                                                                <a href="https://netlover.cn/2018/08/18/csharp-singleton-pattern.html">
                                                                    https://netlover.cn/2018/08/18/csharp-singleton-pattern.html
                                                                </a>
                                                            </p>
                                                            
                                        </div>
                                        <div class="article-info article-info-index">
                                                
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C#</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Singleton-Pattern/">Singleton Pattern</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/单例模式/">单例模式</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/设计模式/">设计模式</a></li></ul>
	</div>


                                                    
                                                        
                                                                <div class="clearfix"></div>
                                            </div>
            </div>
            
                    
                            
                                        
</article>
  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页 &raquo;</a>
    </nav>
  


<script>
    $(function(){
	    var width = document.body.scrollWidth;
		if(width<=550){
		    $("#recentComments").css("display","none");
		}
	})
</script>
</div>
    </div>
    <div class="aside">
      <a href="javascript:;" class="open"></a>
      <a href="javascript:;" class="close"></a>
    </div>
    <div class="hide"><script src="https://s22.cnzz.com/z_stat.php?id=1274486711&web_id=1274486711" language="JavaScript"></script></div>
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css?2018.08.01">
<script src="/fancybox/jquery.fancybox.pack.js?2018.08.01"></script>

<script src="/js/mobile.js?2018.08.01"></script>
<script src="/js/main.js?2018.08.01"></script>
<script src="/js/prefixfree.js?2018.08.01"></script>

<div id="totop">
    <a title="返回顶部">
        <img src="/img/gotop.png" />
    </a>
</div>

<script src="/js/totop.js?2018.08.01"></script>
<script src="/js/share.js?2018.08.01"></script>
  </div>
</body>
</html>
