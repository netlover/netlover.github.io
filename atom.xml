<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Net Lover</title>
  <icon>https://www.gravatar.com/avatar/65b1cd02da88a159ba8fb10984d24e1b</icon>
  <subtitle>.Net Lover &amp; Net Lover</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://netlover.cn/"/>
  <updated>2018-08-19T02:46:13.072Z</updated>
  <id>https://netlover.cn/</id>
  
  <author>
    <name>Net Lover</name>
    <email>netlover@vip.qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C#设计模式(08) - 装饰模式(Decorator Pattern)</title>
    <link href="https://netlover.cn/2018/08/19/csharp-decorator-pattern.html"/>
    <id>https://netlover.cn/2018/08/19/csharp-decorator-pattern.html</id>
    <published>2018-08-19T08:47:44.000Z</published>
    <updated>2018-08-19T02:46:13.072Z</updated>
    
    <summary type="html">
    
      动态地给一个对象增加一些额外的职责。就增加功能而言，Decorator模式比生成子类更为灵活。
    
    </summary>
    
      <category term="C#设计模式" scheme="https://netlover.cn/categories/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="C#" scheme="https://netlover.cn/tags/C/"/>
    
      <category term="设计模式" scheme="https://netlover.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="装饰模式" scheme="https://netlover.cn/tags/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Decorator Pattern" scheme="https://netlover.cn/tags/Decorator-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>C#设计模式(06) - 适配器模式(Adapter Pattern)</title>
    <link href="https://netlover.cn/2018/08/19/csharp-adapter-pattern.html"/>
    <id>https://netlover.cn/2018/08/19/csharp-adapter-pattern.html</id>
    <published>2018-08-19T03:47:44.000Z</published>
    <updated>2018-08-19T02:46:13.070Z</updated>
    
    <summary type="html">
    
      将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
    
    </summary>
    
      <category term="C#设计模式" scheme="https://netlover.cn/categories/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="C#" scheme="https://netlover.cn/tags/C/"/>
    
      <category term="设计模式" scheme="https://netlover.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="适配器模式" scheme="https://netlover.cn/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Adapter Pattern" scheme="https://netlover.cn/tags/Adapter-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>C#设计模式(10) - 外观模式(Facade Pattern)</title>
    <link href="https://netlover.cn/2018/08/19/csharp-facade-pattern.html"/>
    <id>https://netlover.cn/2018/08/19/csharp-facade-pattern.html</id>
    <published>2018-08-19T03:45:44.000Z</published>
    <updated>2018-08-19T02:43:37.869Z</updated>
    
    <summary type="html">
    
      为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。在软件系统开发的过程中，当组件的客户（即外部接口，或客户程序）和组件中各种复杂的子系统有了过多的耦合，随着外部客户程序和各子系统的演化，这种过多的耦合面临很多变化的挑战。如何简化外部客户程序和系统间的交互接口？如何将外部客户程序的演化和内部子系统的变化之间的依赖相互解耦？
    
    </summary>
    
      <category term="C#设计模式" scheme="https://netlover.cn/categories/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="C#" scheme="https://netlover.cn/tags/C/"/>
    
      <category term="设计模式" scheme="https://netlover.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="外观模式" scheme="https://netlover.cn/tags/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Facade Pattern" scheme="https://netlover.cn/tags/Facade-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>C#设计模式(09) - 组合模式(Composite Pattern)</title>
    <link href="https://netlover.cn/2018/08/19/csharp-composite-pattern.html"/>
    <id>https://netlover.cn/2018/08/19/csharp-composite-pattern.html</id>
    <published>2018-08-19T03:10:44.000Z</published>
    <updated>2018-08-19T02:46:13.072Z</updated>
    
    <summary type="html">
    
      将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。客户代码过多地依赖于对象容器（对象容器是对象的容器，细细评味）复杂的内部实现结构，对象容器内部实现结构（而非抽象接口）的变化将引起客户代码的频繁变化，带来了代码的维护性、扩展性等方面的弊端。如何将“客户代码与复杂的对象容器结构”解耦？如何让对象容器自己来实现自身的复杂结构，从而使得客户代码就像处理简单对象一样来处理复杂的对象容器？
    
    </summary>
    
      <category term="C#设计模式" scheme="https://netlover.cn/categories/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="C#" scheme="https://netlover.cn/tags/C/"/>
    
      <category term="设计模式" scheme="https://netlover.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="组合模式" scheme="https://netlover.cn/tags/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Composite Pattern" scheme="https://netlover.cn/tags/Composite-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>C#设计模式(05) - 原型模式(Prototype Pattern)</title>
    <link href="https://netlover.cn/2018/08/18/csharp-prototype-pattern.html"/>
    <id>https://netlover.cn/2018/08/18/csharp-prototype-pattern.html</id>
    <published>2018-08-18T11:47:44.000Z</published>
    <updated>2018-08-19T02:46:13.070Z</updated>
    
    <summary type="html">
    
      在软件系统中，经常面临着“某些结构复杂的对象”的创建工作；由于需求的变化，这些对象经常面临着剧烈的变化，但是它们却拥有比较稳定一致的接口。如何应对这种变化？如何向“客户程序（使用这些对象的程序）”隔离出“这些易变对象”，从而使得“依赖这些易变对象的客户程序”不随着需求改变而改变？
    
    </summary>
    
      <category term="C#设计模式" scheme="https://netlover.cn/categories/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="C#" scheme="https://netlover.cn/tags/C/"/>
    
      <category term="设计模式" scheme="https://netlover.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="原型模式" scheme="https://netlover.cn/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Prototype Pattern" scheme="https://netlover.cn/tags/Prototype-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>C#设计模式(04) - 建造者模式(Builder Pattern)</title>
    <link href="https://netlover.cn/2018/08/18/csharp-builder-pattern.html"/>
    <id>https://netlover.cn/2018/08/18/csharp-builder-pattern.html</id>
    <published>2018-08-18T10:47:44.000Z</published>
    <updated>2018-08-19T02:46:13.069Z</updated>
    
    <summary type="html">
    
      今天我们要讲讲Builder模式，也就是建造者模式，当然也有叫生成器模式的，英文名称是Builder Pattern。在现实生活中，我们经常会遇到一些构成比较复杂的物品，比如：电脑，它就是一个复杂的物品，它主要是由CPU、主板、硬盘、显卡、机箱等组装而成的。手机当然也是复杂物品，由主板，各种芯片，RAM 和ROM  摄像头之类的东西组成。但是无论是电脑还是手机，他们的组装过程是固定的，就拿手机来说，组装流水线是固定的，不变的，但是把不同的主板和其他组件组装在一起就会生产出不同型号的手机。那么在软件系统中是不是也会存在这样的对象呢？答案是肯定的。在软件系统中我们也会遇到类似的复杂对象，并且这个复杂对象的各个部分按照一定的算法组合在一起，此时该对象的创建工作就可以使用Builder模式了，下面我就来详细看看这个模式吧。
    
    </summary>
    
      <category term="C#设计模式" scheme="https://netlover.cn/categories/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="C#" scheme="https://netlover.cn/tags/C/"/>
    
      <category term="设计模式" scheme="https://netlover.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="建造者模式" scheme="https://netlover.cn/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Builder Pattern" scheme="https://netlover.cn/tags/Builder-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>C#设计模式(03) - 抽象工厂模式(Abstract Factory Pattern)</title>
    <link href="https://netlover.cn/2018/08/18/csharp-abstract-factory-pattern.html"/>
    <id>https://netlover.cn/2018/08/18/csharp-abstract-factory-pattern.html</id>
    <published>2018-08-18T09:47:44.000Z</published>
    <updated>2018-08-19T02:46:13.067Z</updated>
    
    <summary type="html">
    
      在软件系统中，经常面临着&quot;一系统相互依赖的对象&quot;的创建工作：同时，由于需求的变化，往往存在更多系列对象的创建工作。如何应对这种变化？如何绕过常规的对象创建方法（new)，提供一种&quot;封装机制&quot;来避免客户程序和这种&quot;多系列具体对象创建工作&quot;的紧耦合？
    
    </summary>
    
      <category term="C#设计模式" scheme="https://netlover.cn/categories/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="C#" scheme="https://netlover.cn/tags/C/"/>
    
      <category term="设计模式" scheme="https://netlover.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="抽象工厂模式" scheme="https://netlover.cn/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Abstract Factory Pattern" scheme="https://netlover.cn/tags/Abstract-Factory-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>C#设计模式(02) - 工厂方法模式(Factory Method Pattern)</title>
    <link href="https://netlover.cn/2018/08/18/csharp-factory-method-pattern.html"/>
    <id>https://netlover.cn/2018/08/18/csharp-factory-method-pattern.html</id>
    <published>2018-08-18T08:54:44.000Z</published>
    <updated>2018-08-19T02:46:13.067Z</updated>
    
    <summary type="html">
    
      如果有新的需求就需要修改工厂类里面创建产品对象实例的那个方法的实现代码，在面向对象设计一个原则就是哪里有变化，我就封装哪里。还有另外两个大的原则，其一是：面向抽象编程，细节和高层实现都要依赖抽象，第二个原则是：多组合，少继承。这三个原则是最根本的原则，学习设计模式必须以这三个原则为基点，否则都是枉然。
    
    </summary>
    
      <category term="C#设计模式" scheme="https://netlover.cn/categories/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="C#" scheme="https://netlover.cn/tags/C/"/>
    
      <category term="设计模式" scheme="https://netlover.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="工厂方法模式" scheme="https://netlover.cn/tags/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Factory Method Pattern" scheme="https://netlover.cn/tags/Factory-Method-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>C#设计模式(01) - 单例模式(Singleton Pattern)</title>
    <link href="https://netlover.cn/2018/08/18/csharp-singleton-pattern.html"/>
    <id>https://netlover.cn/2018/08/18/csharp-singleton-pattern.html</id>
    <published>2018-08-18T08:47:44.000Z</published>
    <updated>2018-08-19T02:46:13.068Z</updated>
    
    <summary type="html">
    
      看了李建忠老师的讲的设计模式已经有一段时间了（这段时间大概有一年多了），自己还没有写过自己的、有关设计模式的文章。这次想写一些关于设计模式的文章，用自己的理解和代码来写，算是复习一遍。写作的过程中也会多看看其他大牛的文章，争取让自己的理解正确，否则把大家带跑偏了，就是我的过错了。今天就开始我们第一个设计模式，该模式是：【单例模式】，英文名称：Singleton Pattern，这个模式很简单，一个类型只需要一个实例，他是创建型的设计模式。为什么叫“创建型”设计模式呢，因为他们有分类。当然了分类的方式不一样，分类的结果也就不一样。
    
    </summary>
    
      <category term="C#设计模式" scheme="https://netlover.cn/categories/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="C#" scheme="https://netlover.cn/tags/C/"/>
    
      <category term="设计模式" scheme="https://netlover.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="单例模式" scheme="https://netlover.cn/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Singleton Pattern" scheme="https://netlover.cn/tags/Singleton-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>C#设计模式(07) - 桥接模式(Bridge Pattern)</title>
    <link href="https://netlover.cn/2018/08/18/csharp-bridge-pattern.html"/>
    <id>https://netlover.cn/2018/08/18/csharp-bridge-pattern.html</id>
    <published>2018-08-18T02:54:44.000Z</published>
    <updated>2018-08-19T02:46:13.070Z</updated>
    
    <summary type="html">
    
      桥模式不能只是认为是抽象和实现的分离，它其实并不仅限于此。其实两个都是抽象的部分，更确切的理解，应该是将一个事物中多个维度的变化分离。将抽象部分与实现部分分离，使它们都可以独立地变化。
    
    </summary>
    
      <category term="C#设计模式" scheme="https://netlover.cn/categories/C-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="C#" scheme="https://netlover.cn/tags/C/"/>
    
      <category term="设计模式" scheme="https://netlover.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="桥接模式" scheme="https://netlover.cn/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="Bridge Pattern" scheme="https://netlover.cn/tags/Bridge-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>中国未来真正的30个商业模式</title>
    <link href="https://netlover.cn/2018/08/17/30shangyemoshi.html"/>
    <id>https://netlover.cn/2018/08/17/30shangyemoshi.html</id>
    <published>2018-08-17T13:35:44.000Z</published>
    <updated>2018-08-17T14:31:04.990Z</updated>
    
    <summary type="html">
    
      如今中国的变换日新月异，甚至可以移步换景。但是万变不离其宗，当你开始关注变化的本质，而不是变换的结果，你就会越来越深刻的体会到其中的那股规律波。
    
    </summary>
    
      <category term="创业" scheme="https://netlover.cn/categories/%E5%88%9B%E4%B8%9A/"/>
    
    
      <category term="创业" scheme="https://netlover.cn/tags/%E5%88%9B%E4%B8%9A/"/>
    
      <category term="商业模式" scheme="https://netlover.cn/tags/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>区块链就是未来，也是一种回到互联网本来意义的方式</title>
    <link href="https://netlover.cn/2018/08/17/qukuailian-weilai.html"/>
    <id>https://netlover.cn/2018/08/17/qukuailian-weilai.html</id>
    <published>2018-08-17T13:24:44.000Z</published>
    <updated>2018-08-17T13:34:08.655Z</updated>
    
    <summary type="html">
    
      周鸿祎说：“这是写区块链最好的一篇文章”，区块链就是未来，也是一种回到互联网本来意义的方式。这组词序并没有任何意义，真正让它们有价值的地方在于，这个词序是由一个被称为 MetaMask 的软件专门为我一个人生产的。
    
    </summary>
    
      <category term="区块链" scheme="https://netlover.cn/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
      <category term="区块链" scheme="https://netlover.cn/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
      <category term="互联网" scheme="https://netlover.cn/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>ExceptionLess本地部署</title>
    <link href="https://netlover.cn/2018/08/16/ExceptionLess-local.html"/>
    <id>https://netlover.cn/2018/08/16/ExceptionLess-local.html</id>
    <published>2018-08-16T15:12:44.000Z</published>
    <updated>2018-08-16T13:44:55.753Z</updated>
    
    <summary type="html">
    
      ExceptionLess是一套免费开源分布式系统日志收集框架，本文主要介绍本地化实现。
    
    </summary>
    
      <category term="Framework" scheme="https://netlover.cn/categories/Framework/"/>
    
    
      <category term="ExceptionLess" scheme="https://netlover.cn/tags/ExceptionLess/"/>
    
      <category term="本地部署" scheme="https://netlover.cn/tags/%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2/"/>
    
      <category term="日志框架" scheme="https://netlover.cn/tags/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>如何成为一个合格的架构师？</title>
    <link href="https://netlover.cn/2018/08/16/do-jiagoushi.html"/>
    <id>https://netlover.cn/2018/08/16/do-jiagoushi.html</id>
    <published>2018-08-16T15:12:44.000Z</published>
    <updated>2018-08-17T14:13:14.512Z</updated>
    
    <summary type="html">
    
      在互联网圈，架构师这个名号的火热程度堪比产品经理，它在产品经理没火之前就已经风生水起。
    
    </summary>
    
      <category term="架构" scheme="https://netlover.cn/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构" scheme="https://netlover.cn/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="架构师" scheme="https://netlover.cn/tags/%E6%9E%B6%E6%9E%84%E5%B8%88/"/>
    
  </entry>
  
  <entry>
    <title>基于vue生态的UI框架推荐</title>
    <link href="https://netlover.cn/2018/08/16/vue-ui-recommend.html"/>
    <id>https://netlover.cn/2018/08/16/vue-ui-recommend.html</id>
    <published>2018-08-16T14:47:44.000Z</published>
    <updated>2018-08-16T13:44:30.938Z</updated>
    
    <summary type="html">
    
      本文主要介绍实际应用中涉及到的几款vue ui，个人觉得不错，特此推荐！
    
    </summary>
    
      <category term="vue" scheme="https://netlover.cn/categories/vue/"/>
    
    
      <category term="vue" scheme="https://netlover.cn/tags/vue/"/>
    
      <category term="ui" scheme="https://netlover.cn/tags/ui/"/>
    
  </entry>
  
  <entry>
    <title>常用meta标签的作用以及全面整理</title>
    <link href="https://netlover.cn/2018/08/15/meta-all.html"/>
    <id>https://netlover.cn/2018/08/15/meta-all.html</id>
    <published>2018-08-15T14:47:44.000Z</published>
    <updated>2018-08-18T15:05:21.969Z</updated>
    
    <summary type="html">
    
      &lt;meta&gt; 标签提供关于 HTML 文档的元数据。它不会显示在页面上，但是对于机器是可读的。可用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他 web 服务。meta里的数据是供机器解读的，告诉机器该如何解析这个页面，还有一个用途是可以添加服务器发送到浏览器的http头部内容。
    
    </summary>
    
      <category term="Html" scheme="https://netlover.cn/categories/Html/"/>
    
    
      <category term="Html" scheme="https://netlover.cn/tags/Html/"/>
    
      <category term="meta" scheme="https://netlover.cn/tags/meta/"/>
    
      <category term="seo" scheme="https://netlover.cn/tags/seo/"/>
    
  </entry>
  
  <entry>
    <title>初步接触hexo</title>
    <link href="https://netlover.cn/2018/08/01/hexo-begin.html"/>
    <id>https://netlover.cn/2018/08/01/hexo-begin.html</id>
    <published>2018-08-01T15:47:44.000Z</published>
    <updated>2018-08-12T13:09:01.540Z</updated>
    
    <summary type="html">
    
      初步接触hexo
    
    </summary>
    
      <category term="Hexo" scheme="https://netlover.cn/categories/Hexo/"/>
    
    
      <category term="hexo" scheme="https://netlover.cn/tags/hexo/"/>
    
      <category term="github" scheme="https://netlover.cn/tags/github/"/>
    
      <category term="blog" scheme="https://netlover.cn/tags/blog/"/>
    
  </entry>
  
</feed>
